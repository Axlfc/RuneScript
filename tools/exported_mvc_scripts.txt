models:
```
file_operations.py:
import subprocess
import sys
from tkinter import filedialog, messagebox, simpledialog
import os

from src.controllers.menu_functions import open_file
from src.localization import localization_data

from src.views.tk_utils import root, directory_label, script_name_label, file_name


def validate_time(hour, minute):
    """
        Validates the given hour and minute to ensure they form a valid time.

        This function checks if the provided hour and minute values form a valid time (HH:MM format). It displays
        an error message if the time is invalid.

        Parameters:
        hour (str or int): The hour part of the time.
        minute (str or int): The minute part of the time.

        Returns:
        bool: True if the time is valid, False otherwise.
    """
    try:
        hour = int(hour)
        minute = int(minute)
        if not (0 <= hour < 24) or not (0 <= minute < 60):
            raise ValueError
        return True
    except ValueError:
        messagebox.showerror("Invalid Time", "Please enter a valid time in HH:MM format.")
        return False


def rename(event=None):
    """
        Renames an existing file after prompting the user for the new file name.

        This function allows the user to specify a new name for an existing file. If the file path is not already
        set, it prompts the user to either enter a file path or select a file using a file dialog. The function then
        carries out the renaming operation and updates the application title.

        Parameters:
        event (optional): An event object representing the event that triggered this function.

        Returns:
        None
    """
    global file_name
    if file_name == "":
        # Prompt the user to enter the file path or select a file using a file dialog
        file_path = simpledialog.askstring("Rename", "Enter file path or select a file")
        if not file_path:
            # User cancelled the operation
            return

        print("File path:", file_path)
        if not os.path.exists(file_path):
            messagebox.showerror("Error", "File does not exist")
            return

        file_name = file_path

    # Extract the directory path and file name
    dir_path, old_name = os.path.split(file_name)
    new_name = simpledialog.askstring("Rename", "Enter new name")

    try:
        # Rename the file
        new_path = os.path.join(dir_path, new_name)
        os.rename(file_name, new_path)
        file_name = new_path
        root.title(file_name + " - Script Editor")
    except OSError as e:
        messagebox.showerror("Error", f"Failed to rename file: {e}")


def select_directory():
    """
        Opens a dialog for the user to select a directory, and changes the current working directory to the selected one.

        After the directory is selected, the function updates the directory label in the UI and opens the first text file
        (if any) in the selected directory.

        Parameters:
        None

        Returns:
        None
    """
    directory = filedialog.askdirectory()
    if directory:
        os.chdir(directory)
        global current_directory  # Declare current_directory as global if it's not in the same file
        current_directory = directory  # Update the current_directory variable
        directory_label.config(text=f"{directory}")
        # Ask user if they want to open the first text file
        if messagebox.askyesno(localization_data['open_script'], localization_data['open_first_file_from_directory']):
            open_first_text_file(directory)


def open_current_directory():
    directory = directory_label.cget("text")
    if sys.platform == "win32":
        os.startfile(directory)
    elif sys.platform == "darwin":
        subprocess.run(["open", directory])
    else:  # Assuming Linux or similar
        subprocess.run(["xdg-open", directory])


def open_first_text_file(directory):
    """
        Opens the first text file in the given directory.

        This function scans the specified directory for text files and, if found, opens the first one. It is typically
        used after changing the working directory to automatically open a text file from that directory.

        Parameters:
        directory (str): The directory path in which to search for text files.

        Returns:
        None
    """
    text_files = get_text_files(directory)
    if text_files:
        file_path = os.path.join(directory, text_files[0])
        open_file(file_path)


def get_text_files(directory):
    """
        Retrieves a list of text files in the specified directory.

        This function scans the provided directory and creates a list of all files ending with a '.txt' extension.

        Parameters:
        directory (str): The directory path in which to search for text files.

        Returns:
        list: A list of text file names found in the directory.
    """
    text_files = []
    for file in os.listdir(directory):
        if file.endswith(".txt"):
            text_files.append(file)
    return text_files


def prompt_rename_file():
    """
    Prompts the user for a new file name and renames or creates the file.
    """
    new_name = simpledialog.askstring("Rename or Create File", "Enter new file name:")
    if new_name:  # Proceed only if the user entered a name
        clean_name = new_name.replace(" ", "_")
        rename_or_create_file(clean_name)


def rename_or_create_file(new_name):
    """
    Renames the current file to the new name provided by the user, or creates a new file if none exists.

    Parameters:
    new_name (str): The new name for the file.
    """
    global file_name
    dir_path = os.path.dirname(file_name) if file_name else os.getcwd()  # Use current directory if file_name is not set
    new_path = os.path.join(dir_path, new_name)

    if file_name and os.path.exists(file_name):
        # If there's a current file, rename it
        try:
            os.rename(file_name, new_path)
            file_name = new_path  # Update the global file_name variable
            script_name_label.config(text=f"File Name: {new_name}")
            messagebox.showinfo("Rename Successful", f"File has been renamed to {new_name}")
        except OSError as e:
            messagebox.showerror("Error", f"Failed to rename file: {e}")
    else:
        # If no current file, try to create a new one
        try:
            with open(new_path, 'w') as new_file:
                new_file.write("")  # Create an empty file
            file_name = new_path  # Update the global file_name variable
            script_name_label.config(text=f"File Name: {new_name}")
            messagebox.showinfo("File Created", f"New file has been created: {new_name}")
        except OSError as e:
            messagebox.showerror("Error", f"Failed to create file: {e}")


def remove_asterisk_from_title():
    """
        Removes an asterisk from the beginning of the application's title if present.

        This function is typically used to update the application's title to indicate that the current file has been saved
        or no longer contains unsaved changes.

        Parameters:
        None

        Returns:
        None
    """
    title = root.title()
    if title.startswith("*"):
        root.title(title[1:])


script_operations.py:
import os
import platform
import re
import subprocess
from time import sleep
from tkinter import messagebox, Toplevel, Text

from src.controllers.utility_functions import validate_time
from src.localization import localization_data
from src.views.tk_utils import script_text, generate_stdin, generate_stdin_err, script_name_label, entry_arguments_entry, \
    directory_label, root


def get_execution_command(file_path, entry_arguments):
    file_extension = os.path.splitext(file_path)[1].lower()
    if file_extension == '.py':
        if platform.system() == "Windows":
            return ['python', file_path] + entry_arguments
        else:
            return ['python3', file_path] + entry_arguments
    elif file_extension == '.sh':
        return ['bash', file_path] + entry_arguments
    elif file_extension == '.ps1':
        if platform.system() == "Windows":
            return ['C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe', "-File",  file_path] + entry_arguments
        else:
            return []
    elif file_extension == '.tex':
        return ['pdflatex', file_path] + entry_arguments
    elif file_extension == '.js':
        return ['node', file_path] + entry_arguments
    elif file_extension == '.html':
        # HTML files are not typically "executed" in the traditional sense
        return []
    elif file_extension == '.css':
        # CSS files are not executed independently
        return []
    elif file_extension == '.csv':
        # CSS files are not executed independently
        return []
    elif file_extension == '.txt':
        # CSS files are not executed independently
        return []
    elif file_extension == '.java':
        return ['java', file_path] + entry_arguments
    elif file_extension == '.cpp':
        return ['g++', file_path, '-o', 'outputfile', '&&', './outputfile'] + entry_arguments
    elif file_extension == '.rb':
        return ['ruby', file_path] + entry_arguments
    elif file_extension == '.pl':
        return ['perl', file_path] + entry_arguments
    elif file_extension == '.php':
        return ['php', file_path] + entry_arguments
    elif file_extension == '.ipynb':
        # You might need a specialized handler for Jupyter notebooks
        return ['jupyter', 'notebook', file_path] + entry_arguments
    elif file_extension == '.swift':
        # Swift scripts can be executed with the 'swift' command
        return ['swift', file_path] + entry_arguments
    elif file_extension == '.go':
        return ['go', 'run', file_path] + entry_arguments
    elif file_extension == '.r':
        return ['Rscript', file_path] + entry_arguments
    elif file_extension == '.rs':
        return ['rustc', file_path, '&&', './' + os.path.splitext(file_path)[0]] + entry_arguments
    elif file_extension == '.dart':
        return ['dart', file_path] + entry_arguments
    # For '.txt', '.csv', and other non-executable files, return an empty list or a viewer command
    else:
        return []


def run_script_windows():
    script = script_text.get("1.0", "end-1c")
    entry_arguments = entry_arguments_entry.get().split()  # Splitting the string into a list
    generate_stdout = generate_stdin.get()
    generate_stderr = generate_stdin_err.get()

    # Extract the file name from the script_name_label's text
    file_name_with_prefix = script_name_label.cget('text')
    file_name = file_name_with_prefix.replace(localization_data['script_name_label'], "").strip()

    current_directory = directory_label.cget('text')
    file_path = os.path.join(current_directory, file_name)

    command = get_execution_command(file_path, entry_arguments)
    if not command:
        print(f"Cannot execute file: {file_name}")
        return

    process = subprocess.Popen(command, stdout=subprocess.PIPE if generate_stdout else None,
                               stderr=subprocess.PIPE if generate_stderr else None,
                               text=True)

    stdout_data, stderr_data = process.communicate()

    # Print the stdout and stderr
    if generate_stdout:
        script_out_name = script_name_label.cget('text') + ".out"
        print(script_out_name)
        with open(script_out_name, "w+") as p:
            p.write(stdout_data)

    if generate_stderr:
        script_err_name = script_name_label.cget('text') + ".err"
        with open(script_err_name, "w+") as p:
            p.write(stderr_data)


def run_script():
    """
        Executes the script present in the script_text widget.

        This function runs the script, capturing standard output and error if specified.
        It supports running scripts with additional arguments and reports the execution status.

        Parameters:
        None

        Returns:
        None
    """
    script = script_text.get("1.0", "end-1c")
    arguments = entry_arguments_entry.get()
    generate_stdout = generate_stdin.get()
    generate_stderr = generate_stdin_err.get()

    try:
        # Execute the script with provided arguments
        # Use the subprocess module to run the script as a separate process
        # result = subprocess.run([script] + arguments.split(), capture_output=True, shell=True)
        # TODO "/"
        process = subprocess.Popen(["bash"] + [directory_label.cget('text') + "/" + script_name_label.cget('text')] + arguments.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        stdout_data, stderr_data = process.communicate()

        # Print the stdout and stderr
        if generate_stdout:
            script_out_name = script_name_label.cget('text') + ".out"
            print(script_out_name)
            p = open(script_out_name, "w+")
            p.write(stdout_data.decode())

        if generate_stderr:
            script_err_name = script_name_label.cget('text') + ".err"
            p = open(script_err_name, "w+")
            p.write(stderr_data.decode())

        messagebox.showinfo("Script Execution", "Script executed successfully.")
    except Exception as e:
        messagebox.showerror("Script Execution", f"Error executing script:\n{str(e)}")


def run_script_with_timeout(timeout_seconds):
    """
        Executes the script with a specified timeout.

        Runs the script and automatically stops it after the provided timeout period.
        It captures standard output and error based on the user's selection.

        Parameters:
        timeout_seconds (float): The duration in seconds after which the script is automatically stopped.

        Returns:
        None
    """
    script = script_text.get("1.0", "end-1c")
    arguments = entry_arguments_entry.get()
    generate_stdout = generate_stdin.get()
    generate_stderr = generate_stdin_err.get()

    try:
        # Execute the script with provided arguments
        # Use the subprocess module to run the script as a separate process
        # result = subprocess.run([script] + arguments.split(), capture_output=True, shell=True)
        # TODO "/"
        process = subprocess.Popen(
            ["bash"] + [directory_label.cget('text') + "/" + script_name_label.cget('text')] + arguments.split(),
            stdout=subprocess.PIPE, stderr=subprocess.PIPE)

        sleep(timeout_seconds)
        stdout_data, stderr_data = process.communicate()

        # Print the stdout and stderr
        if generate_stdout:
            script_out_name = script_name_label.cget('text') + ".out"
            print(script_out_name)
            p = open(script_out_name, "w+")
            p.write(stdout_data.decode())

        if generate_stderr:
            script_err_name = script_name_label.cget('text') + ".err"
            p = open(script_err_name, "w+")
            p.write(stderr_data.decode())

        messagebox.showinfo("Script Execution", "Script executed successfully.")
    except Exception as e:
        messagebox.showerror("Script Execution", f"Error executing script:\n{str(e)}")


def run_script_once(schedule_time):
    """
        Schedules the script for a one-time execution at a specified time.

        The function uses the 'at' command to schedule the script. It validates the provided time format
        and schedules the script accordingly, including redirection of output and error streams.

        Parameters:
        schedule_time (str): The time at which the script is scheduled to run (in HH:MM AM/PM format).

        Returns:
        None
    """
    script_path = os.path.join(directory_label.cget('text'), script_name_label.cget('text'))
    arguments = entry_arguments_entry.get()
    generate_stdout = generate_stdin.get()
    generate_stderr = generate_stdin_err.get()

    # Extract hour, minute, and AM/PM from the input time string
    match = re.match(r'(\d{1,2}):(\d{2})\s*(AM|PM|am|pm)?', schedule_time)
    if not match:
        messagebox.showerror("Invalid Time", "Please enter a valid time in HH:MM AM/PM format.")
        return

    hour = int(match.group(1))
    minute = int(match.group(2))
    am_pm = match.group(3)

    # Adjust hour for 12-hour clock format
    if am_pm and am_pm.lower() == 'pm' and hour != 12:
        hour += 12

    if am_pm and am_pm.lower() == 'am' and hour == 12:
        hour = 0

    if not validate_time(hour, minute):
        return

    try:
        # Use the 'at' command to schedule the script execution and redirection
        at_time = f"{hour:02d}:{minute:02d}"

        stdout_redirect = f">{script_name_label.cget('text')}.out" if generate_stdout else "/dev/null"
        stderr_redirect = f"2>{script_name_label.cget('text')}.err" if generate_stderr else "/dev/null"

        at_command = f"atq; at {at_time} <<EOF\n{script_path} {arguments} {stdout_redirect} {stderr_redirect}\nEOF"

        process = subprocess.Popen(at_command, shell=True)
        process.wait()

        messagebox.showinfo("Script Scheduled", f"Script scheduled to run at {at_time}.")
    except Exception as e:
        messagebox.showerror("Error Scheduling Script", f"An error occurred while scheduling the script:\n{str(e)}")


def run_script_crontab(minute, hour, day, month, day_of_week):
    """
        Schedules the script using the crontab format.

        Sets up a cron job to execute the script at specified intervals. The function builds the cron schedule
        string based on provided parameters and configures output/error redirection.

        Parameters:
        minute, hour, day, month, day_of_week (str): Time parameters for scheduling the script in crontab format.

        Returns:
        None
    """
    if not minute or not hour or not day or not month or not day_of_week:
        messagebox.showerror("Error Scheduling Script", "All cron schedule fields must be filled.")
        return

    # Build the cron schedule string
    cron_schedule = f"{minute} {hour} {day} {month} {day_of_week}"

    script_path = os.path.join(directory_label.cget('text'), script_name_label.cget('text'))
    arguments = entry_arguments_entry.get()

    generate_stdout = generate_stdin.get()
    generate_stderr = generate_stdin_err.get()

    # Determine the full path for .out and .err files based on the selected directory
    out_file = os.path.join(directory_label.cget('text'), f"{script_name_label.cget('text')}.out")
    err_file = os.path.join(directory_label.cget('text'), f"{script_name_label.cget('text')}.err")

    try:
        stdout_redirect = f">{out_file}" if generate_stdout else "/dev/null"
        stderr_redirect = f"2>{err_file}" if generate_stderr else "/dev/null"

        # Use the 'crontab' command to set up the script execution schedule
        crontab_command = f"(crontab -l; echo '{cron_schedule} {script_path} {arguments} {stdout_redirect} {stderr_redirect}') | crontab -"
        process = subprocess.Popen(crontab_command, shell=True)
        process.wait()

        messagebox.showinfo("Script Scheduled", f"Script scheduled with cron: {cron_schedule}")
    except Exception as e:
        messagebox.showerror("Error Scheduling Script", f"An error occurred while scheduling the script:\n{str(e)}")


def see_stdout():
    """
        Displays the standard output of the last executed script.

        Opens a new window to show the content of the script's stdout captured during the last execution.
        If the stdout file is not found, it indicates no available data.

        Parameters:
        None

        Returns:
        None
    """
    stdout_window = Toplevel(root)
    stdout_window.title("Standard Output (stdout)")
    stdout_text = Text(stdout_window)
    stdout_text.pack()

    script_out_name = script_name_label.cget('text') + ".out"
    try:
        with open(script_out_name, "r") as f:
            stdout_text.insert("1.0", f.read())
    except FileNotFoundError:
        stdout_text.insert("1.0", "No stdout data available.")


def see_stderr():
    """
        Displays the standard error output of the last executed script.

        Opens a new window to show the content of the script's stderr captured during the last execution.
        If the stderr file is not found, it indicates no available data. The stderr text is displayed in red.

        Parameters:
        None

        Returns:
        None
    """
    stderr_window = Toplevel(root)
    stderr_window.title("Standard Error (stderr)")
    stderr_text = Text(stderr_window)
    stderr_text.pack()

    script_err_name = script_name_label.cget('text') + ".err"
    try:
        with open(script_err_name, "r") as f:
            stderr_text.insert("1.0", f.read())
    except FileNotFoundError:
        stderr_text.insert("1.0", "No stderr data available.")

    # Configure the text widget to use red font color
    stderr_text.tag_configure("red", foreground="red")
    stderr_text.tag_add("red", "1.0", "end")


def get_operative_system():
    """
        Populates the 'Jobs' submenu with options based on the operating system.

        For Windows, it adds an option to view scheduled tasks. For other systems, it adds options for 'at' and 'crontab' jobs.

        Parameters:
        submenu (Menu): The submenu to which the job options will be added.

        Returns:
        None
    """
    if platform.system() == "Windows":
        return "Windows"
    else:
        return platform.system()


```

views:
```
app_layers.py:
from tkinter import Button, Checkbutton

from src.models.file_operations import select_directory, prompt_rename_file, open_current_directory
from src.controllers.menu_functions import run_icon, redo_icon, undo_icon, save_new_icon, save_icon, open_icon, house_icon, \
    open_script, save_script, save_as_new_script, update_modification_status, on_text_change
from src.models.script_operations import see_stderr, see_stdout, run_script, run_script_with_timeout, run_script_once, \
    run_script_crontab, get_operative_system, run_script_windows
from src.localization import localization_data
from src.views.ui_elements import Tooltip
from src.views.tk_utils import *


def undo():
    """
        Reverts the last action taken in the script text editor.

        This function undoes the last change made to the text in the script editor, allowing for simple
        mistake correction.

        Parameters:
        None

        Returns:
        None
    """
    print("Undo function called.")
    script_text.edit_undo()


def redo():
    """
        Redoes the last action that was undone in the script text editor.

        If an action was undone using the undo function, this function allows the user to redo that action.

        Parameters:
        None

        Returns:
        None
    """
    print("Redo function called.")
    script_text.edit_redo()


def cut():
    """
        Cuts the selected text from the script editor to the clipboard.

        This function removes the currently selected text from the document and places it on the clipboard,
        allowing it to be pasted elsewhere.

        Parameters:
        None

        Returns:
        None
    """
    #set_modified_status(True)
    script_text.event_generate("<<Cut>>")


def copy():
    """
        Copies the selected text from the script editor to the clipboard.

        This function copies the currently selected text to the clipboard without removing it from the document.

        Parameters:
        None

        Returns:
        None
    """
    # set_modified_status(True)
    script_text.event_generate("<<Copy>>")


def paste():
    """
        Pastes text from the clipboard into the script editor at the cursor's current location.

        This function inserts the contents of the clipboard into the document at the current cursor position.

        Parameters:
        None

        Returns:
        None
    """
    # set_modified_status(True)
    script_text.event_generate("<<Paste>>")


def duplicate():
    """
        Duplicates the selected text in the script editor.

        This function creates a copy of the selected text and inserts it immediately after the current selection.

        Parameters:
        None

        Returns:
        None
        """
    # set_modified_status(True)
    script_text.event_generate("<<Duplicate>>")


def create_directory_line():
    """
        Creates and displays the directory selection interface in the application.

        This interface element allows users to select and display the current working directory, facilitating
        the process of opening and saving files in the chosen directory.

        Parameters:
        None

        Returns:
        None
    """
    global current_directory
    frm.grid(row=0, column=0, pady=0, sticky="ew")  # Set sticky to "ew" to fill horizontally
    # Configure grid weights for the columns
    frm.columnconfigure(0, weight=0)  # First column doesn't expand
    frm.columnconfigure(1, weight=1)  # Second column expands

    directory_button = Button(frm, text=house_icon, command=select_directory)
    directory_button.grid(column=0, row=0, sticky="w")
    Tooltip(directory_button, localization_data['choose_working_directory'])

    directory_label.grid(column=1, row=0, padx=5, sticky="ew")  # Set sticky to "ew" to fill horizontally
    directory_label.bind("<Double-1>", lambda event: open_current_directory())
    Tooltip(directory_label, localization_data['current_directory'])


def create_open_script_line():
    """
        Creates the interface elements for opening a script file.

        This includes buttons and labels to facilitate the opening of script files from the file system into the application.

        Parameters:
        None

        Returns:
        None
    """
    script_frm.grid(row=1, column=0, pady=0, sticky="ew")
    script_frm.grid_columnconfigure(2, weight=1)  # Make column 2 (file name entry) expandable

    open_button = Button(script_frm, text=open_icon, command=open_script)
    open_button.grid(column=0, row=0)
    Tooltip(open_button, localization_data['open_script'])

    script_name_label.grid(column=2, row=0, sticky="we", padx=5, pady=5)  # Expand to the right
    script_name_label.bind("<Double-1>", lambda event: prompt_rename_file())
    Tooltip(script_name_label, localization_data['file_name'])

    save_button = Button(script_frm, text=save_icon, command=save_script)
    save_button.grid(column=3, row=0, sticky="e")  # Align to the right
    Tooltip(save_button, localization_data['save_script'])

    save_new_button = Button(script_frm, text=save_new_icon, command=save_as_new_script)
    save_new_button.grid(column=4, row=0, sticky="e")  # Align to the right
    Tooltip(save_new_button, localization_data['save_as_new_script'])

    undo_button = Button(script_frm, text=undo_icon, command=undo)
    undo_button.grid(column=5, row=0, sticky="e")  # Align to the right
    Tooltip(undo_button, localization_data['undo'])

    redo_button = Button(script_frm, text=redo_icon, command=redo)
    redo_button.grid(column=6, row=0, sticky="e")  # Align to the right
    Tooltip(redo_button, localization_data['redo'])


def create_content_file_window():
    """
        Sets up the main text area for file content display and editing.

        This function is responsible for initializing and configuring the main text area where the content of opened files
        is displayed and can be edited by the user.

        Parameters:
        None

        Returns:
        None
    """
    original_text = script_text.get("1.0", "end-1c")  # Store the original text of the file

    def show_context_menu(event):
        # Create the context menu
        context_menu = Menu(root, tearoff=0)
        context_menu.add_command(label=localization_data['cut'], command=cut)
        context_menu.add_command(label=localization_data['copy'], command=copy)
        context_menu.add_command(label=localization_data['paste'], command=paste)
        context_menu.add_command(label=localization_data['duplicate'], command=duplicate)

        # Post the context menu at the cursor location
        context_menu.post(event.x_root, event.y_root)

        # Give focus to the context menu
        context_menu.focus_set()

        def destroy_menu():
            context_menu.unpost()

        # Bind the <Leave> event to destroy the context menu when the mouse cursor leaves it
        context_menu.bind("<Leave>", lambda e: destroy_menu())

        # Bind the <FocusOut> event to destroy the context menu when it loses focus
        context_menu.bind("<FocusOut>", lambda e: destroy_menu())

    script_text.grid(row=2, column=0, padx=0, pady=0, sticky="nsew")
    script_text.configure(bg="#1f1f1f", fg="white")
    script_text.config(insertbackground='#F0F0F0', selectbackground='#4d4d4d')

    script_text.bind("<Button-3>", show_context_menu)
    script_text.bind("<Key>", update_modification_status)  # Add this line to track text insertion
    script_text.bind("<<Modified>>", on_text_change)


def create_arguments_lines():
    """
        Creates the interface for entering script execution arguments.

        This part of the UI allows users to input arguments that will be passed to scripts when they are run, enhancing the
        flexibility and usability of script execution.

        Parameters:
        None

        Returns:
        None
    """
    content_frm.grid(row=3, column=0, pady=0, sticky="ew")  # Set sticky to "ew" to fill horizontally

    entry_arguments_label = Label(content_frm, text=localization_data['entry_arguments'])
    entry_arguments_label.grid(row=0, column=0, padx=5, pady=0, sticky="w")

    entry_placeholder = ""  # Enter arguments...
    entry_arguments_entry.insert(0, entry_placeholder)
    entry_arguments_entry.grid(row=0, column=1, sticky="e")
    Tooltip(entry_arguments_entry, localization_data['enter_arguments'])

    generate_stdin_check = Checkbutton(content_frm, text=localization_data['stdout'], variable=generate_stdin)
    generate_stdin_check.grid(row=0, column=2, sticky="e")  # sticky to "e" for right alignment
    Tooltip(generate_stdin_check, localization_data['generate_stdout'])

    see_stderr_check = Checkbutton(content_frm, text=localization_data['stderr'], variable=generate_stdin_err)
    see_stderr_check.grid(row=0, column=3, padx=10, sticky="e")  # Set sticky to "e" for right alignment
    Tooltip(see_stderr_check, localization_data['generate_stderr'])

    stdout_button = Button(content_frm, text=localization_data['see_stdout'], command=see_stdout)
    stdout_button.grid(column=1, row=1, sticky="e")  # Align to the right
    Tooltip(stdout_button, localization_data['see_stdout_tooltip'])

    stderr_button = Button(content_frm, text=localization_data['see_stderr'], command=see_stderr)
    stderr_button.grid(column=2, row=1, sticky="e")  # Align to the right
    Tooltip(stderr_button, localization_data['see_stderr_tooltip'])


def create_immediately_run_line():
    """
        Sets up the interface for immediate script execution.

        This function adds a button or interface element that allows users to run the currently open script instantly.

        Parameters:
        None

        Returns:
        None
    """
    if get_operative_system() != "Windows":
        run_frm.grid(row=4, column=0, pady=0, sticky="nsew")  # Set sticky to "e" for right alignment

        Label(run_frm, text=localization_data['run_inmediately']).grid(row=0, column=0, sticky="e", padx=5, pady=0)
        run_button = Button(run_frm, text=run_icon, command=run_script)
        run_button.grid(row=0, column=1, sticky="e", padx=5, pady=0)
        Tooltip(run_button, localization_data['run_script'])
    else:
        run_frm.grid(row=4, column=0, pady=0, sticky="nsew")  # Set sticky to "e" for right alignment

        Label(run_frm, text=localization_data['run_inmediately']).grid(row=0, column=0, sticky="e", padx=5, pady=0)
        run_button = Button(run_frm, text=run_icon, command=run_script_windows)
        run_button.grid(row=0, column=1, sticky="e", padx=5, pady=0)
        Tooltip(run_button, localization_data['run_script'])


def create_execute_in_line():
    """
        Creates the UI components for executing a script with a timeout.

        This part of the interface allows the user to specify a timeout duration for script execution, providing
        additional control over how scripts are run.

        Parameters:
        None

        Returns:
        None
    """
    if get_operative_system() != "Windows":
        line_frm.grid(row=5, column=0, pady=0, sticky="nsew")

        Label(line_frm, text=localization_data['script_timeout']).grid(row=0, column=0, sticky="e", padx=5, pady=0)

        seconds_entry = Entry(line_frm, width=15)
        seconds_entry.grid(column=1, row=0, padx=(10, 0))
        Tooltip(seconds_entry, localization_data['number_of_seconds'])

        run_button = Button(line_frm,
                            text=run_icon,
                            command=lambda: run_script_with_timeout(timeout_seconds=float(seconds_entry.get()))
                            )
        run_button.grid(row=0, column=2, sticky="e", padx=15, pady=0)
        Tooltip(run_button, localization_data['set_duration_for_script_execution'])
    else:
        line_frm.grid(row=5, column=0, pady=0, sticky="nsew")

        Label(line_frm, text=localization_data['script_timeout']).grid(row=0, column=0, sticky="e", padx=5, pady=0)

        seconds_entry = Entry(line_frm, width=15)
        seconds_entry.grid(column=1, row=0, padx=(10, 0))
        Tooltip(seconds_entry, localization_data['number_of_seconds'])

        run_button = Button(line_frm,
                            text=run_icon,
                            command=lambda: run_script_with_timeout(timeout_seconds=float(seconds_entry.get()))
                            )
        run_button.grid(row=0, column=2, sticky="e", padx=15, pady=0)
        Tooltip(run_button, localization_data['set_duration_for_script_execution'])


def create_execute_one_time_with_format():
    """
        Sets up the interface elements for scheduling a one-time script execution.

        This function allows users to schedule a script to be run at a specific time, enhancing the scheduler
        capabilities of the application.

        Parameters:
        None

        Returns:
        None
    """
    if get_operative_system() != "Windows":
        one_time_frm.grid(row=6, column=0, pady=0, sticky="nsew")

        Label(one_time_frm, text=localization_data['scheduled_script_execution']).grid(row=0, column=0, sticky="e", padx=5, pady=0)

        date_entry = Entry(one_time_frm, width=15)
        date_entry.grid(column=1, row=0, padx=(10, 0))
        Tooltip(date_entry, localization_data['time_format'])

        run_button = Button(one_time_frm, text=run_icon, command=lambda: run_script_once(date_entry.get()))
        run_button.grid(row=0, column=2, sticky="e", padx=15, pady=0)
        Tooltip(run_button, localization_data['use_at_command'])


def create_program_daily_with_format():
    """
        Creates UI components for setting up daily scheduled script execution.

        This interface enables users to schedule scripts to run daily at specified times, supporting routine
        automation tasks.

        Parameters:
        None

        Returns:
        None
    """
    if get_operative_system() != "Windows":
        daily_frm.grid(row=7, column=0, pady=0, sticky="ew")

        Label(daily_frm, text=localization_data['daily_script_scheduling']).grid(row=0, column=0, sticky="w", padx=5, pady=0)

        minute_entry = Entry(daily_frm, width=2)
        minute_entry.grid(column=1, row=0, padx=(10, 0))
        Tooltip(minute_entry, localization_data['every_minute'])

        hour_entry = Entry(daily_frm, width=2)
        hour_entry.grid(column=2, row=0, padx=(10, 0))
        Tooltip(hour_entry, localization_data['every_hour'])

        day_entry = Entry(daily_frm, width=2)
        day_entry.grid(column=3, row=0, padx=(10, 0))
        Tooltip(day_entry, localization_data['every_day'])

        month_entry = Entry(daily_frm, width=2)
        month_entry.grid(column=4, row=0, padx=(10, 0))
        Tooltip(month_entry, localization_data['every_month'])

        day_of_the_week_entry = Entry(daily_frm, width=2)
        day_of_the_week_entry.grid(column=5, row=0, padx=(10, 0))
        Tooltip(day_of_the_week_entry, localization_data['every_day_of_week'])

        run_button = Button(
            daily_frm, text=run_icon,
            command=lambda: run_script_crontab(minute_entry.get(), hour_entry.get(), day_entry.get(), month_entry.get(), day_of_the_week_entry.get())
        )
        run_button.grid(row=0, column=6, sticky="e", padx=15, pady=0)
        Tooltip(run_button, localization_data['utilize_crontab'])

edit_operations.py:
from tkinter import INSERT, SEL, END
from tkinter.constants import SEL_FIRST, SEL_LAST

from src.views.tk_utils import root, text, script_text


def cut(event=None):
    """
        Cuts the selected text from the editor and places it into the clipboard.
    """
    try:
        # Check if there is selected text
        selected_text = text.get(SEL_FIRST, SEL_LAST)
        root.clipboard_clear()
        root.clipboard_append(string=selected_text)
        text.delete(SEL_FIRST, SEL_LAST)
    except Exception as e:
        # No text is selected
        pass


def copy(event=None):
    """
        Copies the selected text from the editor to the clipboard.
    """
    try:
        selected_text = text.get(SEL_FIRST, SEL_LAST)
        root.clipboard_clear()
        root.clipboard_append(string=selected_text)
    except Exception as e:
        # No text is selected
        pass


def paste(event=None):
    """
        Pastes text from the clipboard into the editor at the current cursor position.

        This function retrieves everything from the clipboard and inserts it at the current cursor position in the editor.

        Parameters:
        event (optional): An event object representing the event that triggered this function.

        Returns:
        None
    """
    # get gives everyting from the clipboard and paste it on the current cursor position
    # it does'nt removes it from the clipboard.
    text.insert(INSERT, root.clipboard_get())


def select_all(event=None):
    """
        Selects all the text within the editor.

        This function adds a 'select' tag from the beginning to the end of the text, effectively selecting all the text.

        Parameters:
        event (optional): An event object representing the event that triggered this function.

        Returns:
        None
    """
    text.tag_add(SEL, "1.0", END)


def delete_all():
    """
        Deletes all text in the editor.

        This function removes all the content in the editor, clearing the text field.

        Parameters:
        None

        Returns:
        None
    """
    text.delete(1.0, END)


def duplicate(event=None):
    """
        Duplicates the selected text in the editor.
    """
    try:
        selected_text = text.get(SEL_FIRST, SEL_LAST)
        text.insert(INSERT, selected_text)
    except Exception as e:
        # No text is selected
        pass


def undo():
    """
        Undoes the last action in the script text editor.

        This function reverts the last change made in the script text editor, typically used for undoing edits.

        Parameters:
        None

        Returns:
        None
    """
    script_text.edit_undo()


def redo():
    """
        Redoes the last undone action in the script text editor.

        If actions were previously undone using the undo function, this function allows redoing those actions.

        Parameters:
        None

        Returns:
        None
    """
    script_text.edit_redo()


def delete():
    """
        Deletes the currently selected text in the editor.

        This function removes the text that is currently selected within the editor.

        Parameters:
        None

        Returns:
        None
    """
    text.delete(index1=SEL_FIRST, index2=SEL_LAST)

tk_utils.py:
from ttkbootstrap import Style

from tkinter import Label, StringVar, IntVar, Frame
from tkinter import scrolledtext, Text, Entry, Menu
import os

new_name = ""
last_saved_content = None  # This will hold the content of the text editor after the last save or when a new file is opened.
context_menu = None
is_modified = False
markdown_render_enabled = False
add_current_main_opened_script_var = False
include_selected_text_in_command = False
original_md_content = None
render_markdown_var = None
rendered_html_content = None


file_name = ""  # Current file name.
current_font_family = "Liberation Mono"
current_font_size = 12
fontColor = '#000000'
fontBackground = '#FFFFFF'

style = Style(theme="journal")
my_themes = style.theme_names()
print(my_themes)
root = style.master

root.iconbitmap("src/views/icon.ico")

toolbar = Frame(root, pady=2)

menu = Menu(root)
root.config(menu=menu)

frm = Frame(root)
directory_label = Label(frm, text=os.getcwd(), anchor="center")

script_frm = Frame(root)
script_name_label = Label(script_frm, text="Script Name: ", anchor="center")

script_text = scrolledtext.ScrolledText(root, wrap="word", height=20, width=60, undo=True)
text = Text(wrap="word", font=("Liberation Mono", 12), background="white", borderwidth=0, highlightthickness=0,
            undo=True)

all_fonts = StringVar()

all_size = StringVar()

entry_text = StringVar()
content_frm = Frame(root)
entry_arguments_entry = Entry(content_frm, textvariable=entry_text, width=40)

generate_stdin = IntVar()
generate_stdin_err = IntVar()

run_frm = Frame(root)

line_frm = Frame(root)

one_time_frm = Frame(root)

daily_frm = Frame(root)


ui_elements.py:
from tkinter import Toplevel, Label, Canvas


class Tooltip:
    def __init__(self, widget, text):
        self.widget = widget
        self.text = text
        self.tooltip = None
        self.widget.bind("<Enter>", self.enter)
        self.widget.bind("<Leave>", self.leave)
        self.widget.bind("<Motion>", self.motion)

    def enter(self, event):
        if not self.tooltip:
            self.show_tooltip(event)

    def leave(self, event):
        self.destroy_tooltip()

    def motion(self, event):
        if self.tooltip:
            self.adjust_tooltip_position(event.x_root, event.y_root)

    def adjust_tooltip_position(self, x, y):
        # Get screen width and height
        screen_width = self.tooltip.winfo_screenwidth()
        screen_height = self.tooltip.winfo_screenheight()

        # Tooltip dimensions (guessing a size, will adjust after widget update)
        tooltip_width = 200
        tooltip_height = 50

        # Offset from cursor position to avoid directly covering it
        offset_x = 14
        offset_y = 14

        # Adjust position to keep tooltip inside screen boundaries
        x = min(x + offset_x, screen_width - tooltip_width)
        y = min(y + offset_y, screen_height - tooltip_height)

        self.tooltip.wm_geometry(f"+{x}+{y}")

    def show_tooltip(self, event):
        self.tooltip = Toplevel()
        # Set initial position offscreen to avoid flicker on Windows
        self.tooltip.wm_geometry("+0+0")
        self.tooltip.wm_overrideredirect(True)
        label = Label(self.tooltip, text=self.text, background="#ffffe0", relief="solid", borderwidth=1)
        label.pack()

        # Adjust position now that we have the widget
        self.adjust_tooltip_position(event.x_root, event.y_root)

    def destroy_tooltip(self):
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None


```

controllers:
```
menu_functions.py:
import os
from tkinter import Menu, Button, messagebox, filedialog, END

from PIL import Image, ImageTk

from src.views.edit_operations import copy, cut, paste, redo, undo, duplicate

from src.controllers.scheduled_tasks import open_cron_window, open_at_window, open_scheduled_tasks_window, open_new_at_task_window, \
    open_new_crontab_task_window
from src.models.script_operations import get_operative_system
from src.controllers.script_tasks import analyze_csv_data, render_markdown_to_html, generate_html_from_markdown, \
    run_javascript_analysis, analyze_generic_text_data, render_latex_to_pdf, generate_latex_pdf, run_python_script, \
    change_interpreter, render_markdown_to_latex
from src.localization import localization_data

from src.views.tk_utils import toolbar, menu, root, script_name_label, script_text, directory_label, is_modified, file_name, last_saved_content
from src.controllers.tool_functions import (find_text, change_color, open_search_replace_dialog, open_terminal_window, \
    open_ai_assistant_window, open_webview, open_ipython_terminal_window, create_url_input_window,
                                            open_change_theme_window)

house_icon = "üè†"
open_icon = "üìÇ"
save_icon = "üíæ"
save_new_icon = "üÜï"
undo_icon = "‚Æ™"
redo_icon = "‚Æ¨"
run_icon = "‚ñ∂"

file_types = [
    ("Python Scripts", "*.py"),
    ("Shell Scripts", "*.sh"),
    ("PowerShell Scripts", "*.ps1"),
    ("Text Files", "*.txt"),
    ("LaTeX Files", "*.tex"),
    ("CSV Files", "*.csv"),
    ("JavaScript Files", "*.js"),
    ("HTML Files", "*.html"),
    ("CSS Files", "*.css"),
    ("Java Files", "*.java"),
    ("C++ Files", "*.cpp"),
    ("Ruby Scripts", "*.rb"),
    ("Perl Scripts", "*.pl"),
    ("PHP Scripts", "*.php"),
    ("Python Notebooks", "*.ipynb"),
    ("Swift Scripts", "*.swift"),
    ("Go Files", "*.go"),
    ("R Scripts", "*.r"),
    ("Rust Files", "*.rs"),
    ("Dart Files", "*.dart"),
    ("All Files", "*.*")
]


# Help Menu
def about(event=None):
    """
        Displays the 'About' information of the application.

        This function triggers a messagebox that provides details about the ScriptsEditor, including its creation and version.

        Parameters:
        event (optional): An event object, not directly used in this function.

        Returns:
        None
    """
    messagebox.showinfo(localization_data['about_scripts_editor'],
                        localization_data['scripts_editor_info'])


def set_modified_status(value):
    """
        Sets the modified status of the current file.

        This function updates the global 'is_modified' flag to the given value, indicating whether the current file
        has unsaved changes.

        Parameters:
        value (bool): The modified status to set (True or False).

        Returns:
        None
    """
    global is_modified  # Add file_name to the global declaration
    is_modified = value
    update_title()


def update_title():
    """
    Updates the application window's title based on the file's modified status and the current file name.
    """
    global is_modified

    title = os.path.basename(file_name) if file_name else localization_data['untitled']

    if is_modified:
        root.title(f"*{title} - {localization_data['scripts_editor']}")
    else:
        root.title(f"{title} - {localization_data['scripts_editor']}")

    script_name_label.config(text=f"{localization_data['script_name_label']}{os.path.basename(title)}")


def new():
    """
        Creates a new file in the editor.
        Prompts the user to save the current file if it is modified, then clears the text editor.
    """
    global is_modified
    if is_modified:
        response = messagebox.askyesnocancel(localization_data['save_file'], localization_data['save_changes_confirmation'])
        if response:  # User chose 'Yes'
            save()
            clear_editor()
        elif response is None:  # User chose 'Cancel'
            return  # Cancel new file operation
        elif not response:
            clear_editor()

    file_name = ""
    clear_editor()  # Clears the editor after handling the save dialog


def clear_editor():
    """
        Clears the text editor and resets the title and modified flag.
    """
    global file_name
    global is_modified

    script_text.delete('1.0', 'end')
    file_name = ""
    is_modified = False
    update_title()


def on_text_change(event=None):
    """
        Updates the modified flag when text in the editor changes.
    """
    global is_modified
    current_content = script_text.get("1.0", END).strip()

    # Check if the content is empty and if the file is considered 'new' (i.e., not yet saved or loaded from disk)
    if current_content != last_saved_content:
        if not is_modified:  # Update only if there are changes
            is_modified = True
            update_title()
            print("DEBUG: WE REACHED ORIGINAL FILE TEXT CONTENT")  # Debug print statement added
    elif not current_content and (not file_name or file_name == "Untitled"):
        if is_modified:  # Only update if the status is currently 'modified'
            is_modified = False
            update_title()
    else:
        if not is_modified:  # Only update if the status is currently 'not modified'
            is_modified = True
            update_title()


def open_script():
    """
        Opens an existing file into the script editor.

        This function displays a file dialog for the user to choose a file. Once a file is selected, it is opened
        and its contents are displayed in the script editor.

        Parameters:
        None

        Returns:
        None
    """
    if is_modified:
        response = messagebox.askyesnocancel(localization_data['save_changes'],
                                             localization_data['save_confirmation'])
        if response:  # User wants to save changes
            if not save():
                return  # If save was not successful, cancel the file open operation
        elif response is None:  # User cancelled the prompt
            return  # Cancel the file open operation

    # If there are no unsaved changes, or the user has dealt with them, show the open file dialog
    file_path = filedialog.askopenfilename(filetypes=file_types)
    if file_path:
        open_file(file_path)


def open_file(file_path):
    """
        Opens the specified file and updates the editor with its contents.

        This function reads the content from the specified file path and updates the script editor. It tries various
        encodings to ensure correct file reading and updates the UI based on the file extension.

        Parameters:
        file_path (str): The path of the file to open.

        Returns:
        None
    """
    global is_modified, file_name, last_saved_content

    file_name = file_path
    # Update the directory label with the directory of the opened file
    directory_path = os.path.dirname(file_path)
    directory_label.config(text=f"{directory_path}")
    script_name_label.config(text=f"{localization_data['save_changes']}{os.path.basename(file_path)}")

    # Try opening the file with different encodings
    encodings = ['utf-8', 'cp1252', 'ISO-8859-1', 'utf-16']
    for encoding in encodings:
        try:
            with open(file_path, 'r', encoding=encoding) as file:
                script_content = file.read()
                break
        except UnicodeDecodeError:
            continue
    else:
        # If all encodings fail, use 'utf-8' with 'replace' option
        with open(file_path, 'r', encoding='utf-8', errors='replace') as file:
            script_content = file.read()
            last_saved_content = script_content  # Update the last saved content

    script_text.delete("1.0", END)
    script_text.insert("1.0", script_content)

    # Update dynamic menu and title based on file extension
    ext = os.path.splitext(file_path)[1]
    update_menu_based_on_extension(ext)
    # Reset the modified flag after loading the file
    is_modified = False
    update_title()


def create_csv_menu(parent_menu):
    """
        Creates a submenu for CSV-related operations.

        This function adds specific options related to CSV files, such as data analysis, to the given parent menu.

        Parameters:
        parent_menu (Menu): The parent menu to which the CSV submenu will be added.

        Returns:
        None
    """
    entries = {
        "Analyze Data": analyze_csv_data
    }
    create_submenu(parent_menu, "CSV", entries)


def create_bash_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_powershell_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_markdown_menu(parent_menu):
    entries = {
        "Render HTML": render_markdown_to_html,
        "Generate HTML": generate_html_from_markdown,
        "Render LaTeX PDF": render_markdown_to_latex
    }
    create_submenu(parent_menu, "Markdown", entries)


def create_javascript_menu(parent_menu):
    entries = {
        "Analyze Data": run_javascript_analysis
    }
    create_submenu(parent_menu, "JavaScript", entries)


def create_html_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_css_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_java_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_cpp_menu(parent_menu):
    parent_menu.add_command(label="Analyze Data")


def create_generic_text_menu(parent_menu):
    entries = {
        "Analyze Data": analyze_generic_text_data
    }
    create_submenu(parent_menu, "Text", entries)


def create_latex_menu(parent_menu):
    entries = {
        "Render PDF": render_latex_to_pdf,
        "Generate PDF": generate_latex_pdf
    }
    create_submenu(parent_menu, "LaTeX", entries)


def create_python_menu(parent_menu):
    entries = {
        "Execute Python Script": run_python_script,
        "Change Interpreter": change_interpreter
        # Add more options as needed
    }
    create_submenu(parent_menu, "Interpreter", entries)


def update_menu_based_on_extension(ext):
    """
        Updates the application menu based on the file extension of the currently open file.

        This function creates and inserts a dynamic menu specific to the file type of the currently open file.

        Parameters:
        ext (str): The file extension of the currently open file.

        Returns:
        None
    """
    print(f"Debug: Starting to update menu for extension: {ext}")
    menu_creators = {
        ".py": create_python_menu,
        ".csv": create_csv_menu,
        ".txt": create_generic_text_menu,
        ".md": create_markdown_menu,
        ".js": create_javascript_menu,
        ".html": create_html_menu,
        ".css": create_css_menu,
        ".java": create_java_menu,
        ".cpp": create_cpp_menu,
        ".tex": create_latex_menu,
        ".sh": create_bash_menu,
        ".ps1": create_powershell_menu
        # Add other file types and their corresponding menu creators here...
    }

    # Define file type labels
    file_type_labels = {
        ".py": "Python",
        ".csv": "CSV",
        ".txt": "Text",
        ".md": "Markdown",
        ".js": "Javascript",
        ".html": "HTML",
        ".css": "CSS",
        ".java": "Java",
        ".cpp": "C++",
        ".tex": "LaTeX",
        ".sh": "Bash",
        ".ps1": "PowerShell"
        # ... (add labels for other file types)
    }

    # Find the index of the Help menu
    help_menu_index = None
    for index in range(menu.index('end'), -1, -1):
        try:
            if 'Jobs' in menu.entrycget(index, 'label'):
                jobs_menu_index = index
                break
        except Exception as e:
            print(f"Debug: Skipping index {index} due to error: {e}")

    if jobs_menu_index is None:
        print("Debug: Jobs menu not found. Cannot insert dynamic menu correctly.")
        return  # Optionally, raise an exception or handle it as needed

    print(f"Debug: Found Jobs menu at index: {jobs_menu_index}")

    # Check if the dynamic menu already exists, if so, delete it
    dynamic_menu_index = None
    for index, item in enumerate(menu.winfo_children()):
        if isinstance(item, Menu) and item.winfo_name() == 'dynamic':
            dynamic_menu_index = index
            menu.delete(dynamic_menu_index)
            print(f"Debug: Deleted existing dynamic menu at index: {dynamic_menu_index}")
            break

    # Create and insert the new dynamic menu
    dynamic_menu = Menu(menu, tearoff=0, name='dynamic')
    if ext in menu_creators:
        menu_creators[ext](dynamic_menu)
        label = file_type_labels.get(ext, "Other")
    else:
        create_generic_text_menu(dynamic_menu)
        label = "Other"

    # Insert the dynamic menu after the Jobs menu
    menu.insert_cascade(jobs_menu_index + 1, label=label, menu=dynamic_menu)
    print(f"Debug: Inserted new dynamic menu '{label}' after Jobs menu at index: {jobs_menu_index + 1}")


def update_title_with_filename(file_name):
    """
        Updates the window title with the name of the currently open file.

        This function sets the application window's title to include the base name of the given file path.

        Parameters:
        file_name (str): The full path of the currently open file.

        Returns:
        None
    """
    # Esta funci√≥n actualizar√° el t√≠tulo de la ventana con el nuevo nombre de archivo
    base_name = os.path.basename(file_name)
    root.title(f"{base_name} - Scripts Editor")


def update_modification_status(event):
    """
        Updates the modification status of the file to 'modified'.

        This function should be called whenever a change is made to the text content, setting the file's status
        as modified.

        Parameters:
        event: The event object representing the triggering event.

        Returns:
        None
    """
    set_modified_status(True)


def save():
    """
    Saves the current file. If the file doesn't have a name, calls 'save_as' function.
    """
    global is_modified, file_name

    if not file_name or file_name == "Untitled":
        return save_as()  # If no filename, use 'Save As' to get a new filename

    try:
        with open(file_name, 'w', encoding='utf-8') as file:
            file.write(script_text.get('1.0', 'end-1c'))
            is_modified = False
            update_title()
            messagebox.showinfo("Save", "File saved successfully!")
            return True
    except Exception as e:
        messagebox.showerror("Save Error", f"An error occurred: {e}")
        return False


def save_as():
    print("ENTERING SAVE AS")
    """
        Opens a 'Save As' dialog to save the current file with a specified name.
    """
    global file_name
    global is_modified

    new_file_name = filedialog.asksaveasfilename(defaultextension=".*", filetypes=file_types)
    if not new_file_name:
        return False

    file_name = new_file_name
    save()
    update_script_name_label(new_file_name)
    update_title()
    return True


def close(event=None):
    if save():  # Proceed only if the user saves the file or chooses not to save
        root.quit()


def save_file(file_name, content):
    with open(file_name, "w", encoding='utf-8') as file:
        file.write(content)
    messagebox.showinfo("Save", "Script saved successfully!")


def save_script():
    """
    Triggered when 'Save' is clicked. Saves the current file or prompts to save as new if it's a new file.
    """
    global file_name, is_modified

    if not file_name or file_name == "Untitled":
        # If the file is new (i.e., no file_name or it's 'Untitled'), use 'save_as_new_script'
        print("Saving new script...")
        save_as_new_script()
    else:
        # If the file exists, just save it
        print("Saving existing script...")
        content = script_text.get("1.0", "end-1c")  # Get text from editor
        try:
            with open(file_name, 'w', encoding='utf-8') as file:
                file.write(content)
            is_modified = False  # Reset modification status
            update_title()  # Update the window title
            update_script_name_label(file_name)  # Ensure the script name label is updated
            messagebox.showinfo("Save", "File saved successfully!")
        except Exception as e:
            messagebox.showerror("Save Error", f"An error occurred while saving: {e}")


def save_as_new_script():
    """
    Saves the current content as a new file. Opens a file dialog for the user to choose where to save.
    """
    global file_name, is_modified

    new_file_name = filedialog.asksaveasfilename(defaultextension=".*", filetypes=file_types)
    if not new_file_name:
        return  # User cancelled the 'Save As' operation

    file_name = new_file_name  # Update file name
    save_script()  # Call save_script to save the file


def update_script_name_label(file_path):
    """
    Updates the script name label with the base name of the provided file path.
    """
    base_name = os.path.basename(file_path)
    script_name_label.config(text=f"File Name: {base_name}")


# TOOLBAR BUTTONS
# new
new_button = Button(name="toolbar_b2", borderwidth=1, command=new, width=20, height=20)
photo_new = Image.open("icons/new.png")
photo_new = photo_new.resize((18, 18), Image.LANCZOS)
image_new = ImageTk.PhotoImage(photo_new)
new_button.config(image=image_new)
new_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# save
save_button = Button(name="toolbar_b1", borderwidth=1, command=save, width=20, height=20)
photo_save = Image.open("icons/save.png")
photo_save = photo_save.resize((18, 18), Image.LANCZOS)
image_save = ImageTk.PhotoImage(photo_save)
save_button.config(image=image_save)
save_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# open
open_button = Button(name="toolbar_b3", borderwidth=1, command=open_file, width=20, height=20)
photo_open = Image.open("icons/open.png")
photo_open = photo_open.resize((18, 18), Image.LANCZOS)
image_open = ImageTk.PhotoImage(photo_open)
open_button.config(image=image_open)
open_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# copy
copy_button = Button(name="toolbar_b4", borderwidth=1, command=copy, width=20, height=20)
photo_copy = Image.open("icons/copy.png")
photo_copy = photo_copy.resize((18, 18), Image.LANCZOS)
image_copy = ImageTk.PhotoImage(photo_copy)
copy_button.config(image=image_copy)
copy_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# cut
cut_button = Button(name="toolbar_b5", borderwidth=1, command=cut, width=20, height=20)
photo_cut = Image.open("icons/cut.png")
photo_cut = photo_cut.resize((18, 18), Image.LANCZOS)
image_cut = ImageTk.PhotoImage(photo_cut)
cut_button.config(image=image_cut)
cut_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# paste
paste_button = Button(name="toolbar_b6", borderwidth=1, command=paste, width=20, height=20)
photo_paste = Image.open("icons/paste.png")
photo_paste = photo_paste.resize((18, 18), Image.LANCZOS)
image_paste = ImageTk.PhotoImage(photo_paste)
paste_button.config(image=image_paste)
paste_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# duplicate
duplicate_button = Button(name="toolbar_b7", borderwidth=1, command=duplicate, width=20, height=20)
photo_duplicate = Image.open("icons/duplicate.png")
photo_duplicate = photo_paste.resize((18, 18), Image.LANCZOS)
image_duplicate = ImageTk.PhotoImage(photo_paste)
duplicate_button.config(image=image_duplicate)
duplicate_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# redo
redo_button = Button(name="toolbar_b8", borderwidth=1, command=redo, width=20, height=20)
photo_redo = Image.open("icons/redo.png")
photo_redo = photo_redo.resize((18, 18), Image.LANCZOS)
image_redo = ImageTk.PhotoImage(photo_redo)
redo_button.config(image=image_redo)
redo_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# undo
undo_button = Button(name="toolbar_b9", borderwidth=1, command=undo, width=20, height=20)
photo_undo = Image.open("icons/undo.png")
photo_undo = photo_undo.resize((18, 18), Image.LANCZOS)
image_undo = ImageTk.PhotoImage(photo_undo)
undo_button.config(image=image_undo)
undo_button.pack(in_=toolbar, side="left", padx=4, pady=4)

# find
find_button = Button(name="toolbar_b10", borderwidth=1, command=find_text, width=20, height=20)
photo_find = Image.open("icons/find.png")
photo_find = photo_find.resize((18, 18), Image.LANCZOS)
image_find = ImageTk.PhotoImage(photo_find)
find_button.config(image=image_find)
find_button.pack(in_=toolbar, side="left", padx=4, pady=4)


def create_menu():
    """
        Creates and adds the main menu to the application window.

        This function sets up the menu bar at the top of the application, adding file, edit, and other menus
        with their respective menu items and functionalities.

        Parameters:
        None

        Returns:
        None
    """
    # File menu.
    file_menu = Menu(menu)
    menu.add_cascade(label=localization_data['file'], menu=file_menu, underline=0)

    file_menu.add_command(label="New", command=new, compound='left', image=image_new, accelerator='Ctrl+N',
                          underline=0)  # command passed is here the method defined above.
    file_menu.add_command(label="Open", command=open_script, compound='left', image=image_open, accelerator='Ctrl+O',
                          underline=0)
    file_menu.add_separator()
    file_menu.add_command(label="Save", command=save_script, compound='left', image=image_save, accelerator='Ctrl+S',
                          underline=0)
    file_menu.add_command(label="Save As", command=save_as_new_script, accelerator='Ctrl+Shift+S', underline=1)
    # file_menu.add_command(label="Rename", command=rename, accelerator='Ctrl+Shift+R', underline=0)
    file_menu.add_separator()
    file_menu.add_command(label="Close", command=close, accelerator='Alt+F4', underline=0)

    # Edit Menu.
    edit_menu = Menu(menu)
    menu.add_cascade(label="Edit", menu=edit_menu, underline=0)

    edit_menu.add_command(label="Undo",
                          command=undo,
                          compound='left',
                          image=image_undo,
                          accelerator='Ctrl+Z',
                          underline=0
                          )
    edit_menu.add_command(label="Redo",
                          command=redo,
                          compound='left',
                          image=image_redo,
                          accelerator='Ctrl+Y',
                          underline=0
                          )

    edit_menu.add_separator()

    edit_menu.add_command(label="Cut",
                          command=cut,
                          compound='left',
                          image=image_cut,
                          accelerator='Ctrl+X',
                          underline=0
                          )
    edit_menu.add_command(label="Copy",
                          command=copy,
                          compound='left',
                          image=image_copy,
                          accelerator='Ctrl+C',
                          underline=1
                          )
    edit_menu.add_command(label="Paste",
                          command=paste,
                          compound='left',
                          image=image_paste,
                          accelerator='Ctrl+P',
                          underline=0
                          )
    edit_menu.add_command(label="Duplicate",
                          command=duplicate,
                          compound='left',
                          image=image_duplicate,
                          accelerator='Ctrl+D',
                          underline=0
                          )
    # edit_menu.add_command(label="Delete", command=delete, underline=0)
    #edit_menu.add_separator()
    #edit_menu.add_command(label="Select All", command=select_all, accelerator='Ctrl+A', underline=0)
    #edit_menu.add_command(label="Clear All", command=delete_all, underline=6)

    # Tool Menu
    tool_menu = Menu(menu)
    menu.add_cascade(label="Tools", menu=tool_menu, underline=0)

    tool_menu.add_command(label="Change Color", command=change_color)
    tool_menu.add_command(label="Change Theme", command=open_change_theme_window)
    tool_menu.add_command(label="Search", command=find_text, compound='left', image=image_find, accelerator='Ctrl+F')
    tool_menu.add_command(label="Search and Replace", command=open_search_replace_dialog, compound='left',
                          image=image_find, accelerator='Ctrl+R')
    tool_menu.add_separator()
    tool_menu.add_command(label="Terminal", command=open_terminal_window)
    # tool_menu.add_command(label="IPython Terminal", command=open_ipython_terminal_window)
    tool_menu.add_command(label="AI Assistant", command=open_ai_assistant_window)
    tool_menu.add_command(label="BlackBox", command=lambda: open_webview('BlackBox', 'https://www.blackbox.ai/form'))
    tool_menu.add_command(label="Web Browser", command=create_url_input_window)
    tool_menu.add_command(label="big-AGI", command=lambda: open_webview('big-AGI', 'http://localhost:3000'))

    # Jobs Menu
    jobs_menu = Menu(menu)
    menu.add_cascade(label="Jobs", menu=jobs_menu, underline=0)
    jobs_menu.add_command(label="New 'at'", command=open_new_at_task_window)
    jobs_menu.add_command(label="New 'crontab'", command=open_new_crontab_task_window)
    jobs_menu.add_separator()
    get_scheduled_tasks(jobs_menu)

    help_menu = Menu(menu)
    menu.add_cascade(label="Help", menu=help_menu, underline=0)
    help_menu.add_command(label="About", command=about, accelerator='Ctrl+H', underline=0)


def get_scheduled_tasks(submenu):
    """
        Populates the 'Jobs' submenu with options based on the operating system.

        For Windows, it adds an option to view scheduled tasks. For other systems, it adds options for 'at' and 'crontab' jobs.

        Parameters:
        submenu (Menu): The submenu to which the job options will be added.

        Returns:
        None
    """
    if get_operative_system() == "Windows":
        submenu.add_command(label="Scheduled Tasks", command=open_scheduled_tasks_window)
    else:
        submenu.add_command(label="at", command=open_at_window)
        submenu.add_command(label="crontab", command=open_cron_window)


def create_submenu(parent_menu, title, entries):
    """
        Creates a submenu with specified entries under the given parent menu.

        Parameters:
        parent_menu (Menu): The parent menu to which the submenu will be added.
        title (str): The title of the submenu.
        entries (dict): A dictionary of menu item labels and their corresponding command functions.

        Returns:
        None
    """
    submenu = Menu(parent_menu, tearoff=0)
    parent_menu.add_cascade(label=title, menu=submenu)

    for label, command in entries.items():
        submenu.add_command(label=label, command=command)


scheduled_tasks.py:
import os
import subprocess
import tempfile
from tkinter import END, Toplevel, Listbox, Button, messagebox, Label, Entry

from src.views.tk_utils import root
from lib.winTaskScheduler import list_tasks, delete_task, at_function, crontab_function


def open_at_window():
    """
        Opens a window displaying the list of scheduled 'at' jobs.

        This function creates a new window that lists all currently scheduled 'at' jobs. It provides
        an interface for viewing and removing these jobs. The list is updated periodically.

        Parameters:
        None

        Returns:
        None
    """
    def update_at_jobs():
        listbox.delete(0, END)
        populate_at_jobs(listbox)
        at_window.after(5000, update_at_jobs)

    global at_window
    at_window = Toplevel(root)
    at_window.title("AT Jobs")
    at_window.geometry("600x400")

    listbox = Listbox(at_window, width=80)
    listbox.pack(fill="both", expand=True)

    populate_at_jobs(listbox)

    remove_button = Button(at_window, text="Remove Selected", command=lambda: remove_selected_at_job(listbox))
    remove_button.pack(side="bottom")

    at_window.after(0, update_at_jobs)
    at_window.mainloop()


def populate_at_jobs(listbox):
    """
        Populates the given listbox with the current 'at' jobs.

        Retrieves the list of scheduled 'at' jobs and displays them in the provided listbox widget.
        If there are no jobs or an error occurs, an appropriate message is displayed.

        Parameters:
        listbox (Listbox): The Listbox widget to populate with 'at' jobs.

        Returns:
        None
    """
    try:
        at_output = subprocess.check_output(["atq"], text=True).splitlines()
        if not at_output:
            username = subprocess.check_output(["whoami"], text=True).strip()  # Get the current user
            listbox.insert(END, f"No AT jobs found for user {username}.")
        else:
            for line in at_output:
                listbox.insert(END, line)
    except subprocess.CalledProcessError:
        messagebox.showerror("Error", "Failed to retrieve AT jobs")


def remove_selected_at_job(listbox):
    """
        Removes the selected 'at' job from the schedule.

        This function deletes the 'at' job that is currently selected in the listbox. It also handles
        exceptions if the job cannot be removed.

        Parameters:
        listbox (Listbox): The Listbox widget containing the list of 'at' jobs.

        Returns:
        None
    """
    selected_indices = listbox.curselection()
    if not selected_indices:
        return

    selected_index = selected_indices[0]
    selected_item = listbox.get(selected_index)

    if "No AT jobs found for user" in selected_item:
        listbox.delete(selected_index)  # Delete the special message
    else:
        job_id = selected_item.split()[0]
        try:
            subprocess.run(["atrm", job_id], check=True)
            listbox.delete(selected_index)
        except subprocess.CalledProcessError:
            messagebox.showerror("Error", f"Failed to remove AT job {job_id}")


def open_cron_window():
    """
        Opens a window displaying the list of scheduled 'cron' jobs.

        This function creates a new window that lists all currently scheduled 'cron' jobs. It provides
        an interface for viewing and removing these jobs. The list is updated periodically.

        Parameters:
        None

        Returns:
        None
    """
    def update_cron_jobs():
        listbox.delete(0, END)
        populate_cron_jobs(listbox)
        crontab_window.after(5000, update_cron_jobs)

    global crontab_window
    crontab_window = Toplevel(root)
    crontab_window.title("Cron Jobs")
    crontab_window.geometry("600x400")

    listbox = Listbox(crontab_window, width=80)
    listbox.pack(fill="both", expand=True)

    listbox.insert(END, "Loading cron jobs...")  # Initial message while loading
    populate_cron_jobs(listbox)

    remove_button = Button(crontab_window, text="Remove Selected", command=lambda: remove_selected_cron_job(listbox))
    remove_button.pack(side="bottom")

    crontab_window.after(0, update_cron_jobs)
    crontab_window.mainloop()


def populate_cron_jobs(listbox):
    """
        Populates the given listbox with the current 'cron' jobs.

        Retrieves the list of scheduled 'cron' jobs and displays them in the provided listbox widget.
        If there are no jobs or an error occurs, an appropriate message is displayed.

        Parameters:
        listbox (Listbox): The Listbox widget to populate with 'cron' jobs.

        Returns:
        None
    """
    try:
        cron_output = subprocess.check_output(["crontab", "-l"], text=True).splitlines()
        # print("hola" + cron_output)
        if not cron_output:
            username = subprocess.check_output(["whoami"], text=True).strip()  # Get the current user
            listbox.insert(END, f"No cron jobs found for user {username}.")
        else:
            for line in cron_output:
                listbox.insert(END, line)
    except subprocess.CalledProcessError:
        username = subprocess.check_output(["whoami"], text=True).strip()  # Get the current user
        listbox.insert(END, f"No cron jobs found for user {username}.")
        #messagebox.showwarning("Warning", "Failed to retrieve cron jobs")


def remove_selected_cron_job(listbox):
    """
        Removes the selected 'cron' job from the schedule.

        This function deletes the 'cron' job that is currently selected in the listbox. It handles
        exceptions if the job cannot be removed and updates the crontab accordingly.

        Parameters:
        listbox (Listbox): The Listbox widget containing the list of 'cron' jobs.

        Returns:
        None
    """
    selected_indices = listbox.curselection()
    if not selected_indices:
        return

    selected_index = selected_indices[0]
    selected_job = listbox.get(selected_index)

    try:
        # Create a temporary file to store modified crontab
        temp_file = tempfile.NamedTemporaryFile(delete=False)

        # Save the current crontab to the temporary file
        subprocess.run(["crontab", "-l"], text=True, stdout=temp_file)

        # Reset the file pointer to the beginning
        temp_file.seek(0)

        selected_job_bytes = selected_job.encode("utf-8")

        # Filter out the selected job and write to a new temporary file
        filtered_lines = [line for line in temp_file if selected_job_bytes not in line]

        temp_file.close()

        # Write the filtered content back to the temporary file
        with open(temp_file.name, "wb") as f:
            f.writelines(filtered_lines)

        # Load the modified crontab from the temporary file
        subprocess.run(["crontab", temp_file.name], check=True)

        # Delete the temporary file
        os.remove(temp_file.name)

        # Remove the item from the listbox
        listbox.delete(selected_index)

    except subprocess.CalledProcessError:
        messagebox.showerror("Error", "Failed to remove cron job")


def open_scheduled_tasks_window():
    """
        Opens a window for managing scheduled tasks.

        This function creates a new window displaying all scheduled tasks, allowing the user to view and
        delete them. It supports both 'at' and 'cron' jobs based on the operating system.

        Parameters:
        None

        Returns:
        None
    """
    window = Toplevel()
    window.title("Scheduled Tasks")
    window.geometry("600x400")

    listbox = Listbox(window, width=80)
    listbox.pack(fill="both", expand=True)

    # This variable will hold the last selected task index
    last_selected_index = [None]

    def populate_tasks():
        # Remember the last selected item
        if listbox.curselection():
            last_selected_index[0] = listbox.curselection()[0]
        listbox.delete(0, END)
        tasks = list_tasks()  # Get the list of tasks
        for task in tasks:
            listbox.insert(END, task)
        # Set the selection back to the last selected item if it exists
        if last_selected_index[0] is not None and last_selected_index[0] < listbox.size():
            listbox.selection_set(last_selected_index[0])
            listbox.see(last_selected_index[0])

    def delete_selected_task():
        selection = listbox.curselection()
        if not selection:
            messagebox.showerror("Error", "No task selected")
            return

        selected_task_info = listbox.get(selection[0])
        print("THE SELECTED_TASK_INFO IS:\n", selected_task_info)
        task_name = selected_task_info.split('\"')[1]
        try:
            delete_task(task_name)
            populate_tasks()  # Refresh the list
            last_selected_index[0] = None  # Reset the last selected index
        except Exception as e:
            messagebox.showerror("Error", f"Failed to delete task: {e}")

    def update_tasks():
        populate_tasks()
        window.after(5000, update_tasks)  # Schedule next update

    populate_tasks()  # Initial population of the list
    update_tasks()    # Start the periodic update

    delete_button = Button(window, text="Delete Selected", command=delete_selected_task)
    delete_button.pack()

    window.mainloop()


def open_new_at_task_window():
    """
        Opens a window for creating a new 'at' task.

        Provides an interface for the user to schedule a new 'at' job by specifying the task name, time,
        and program path. Includes error handling for task creation.

        Parameters:
        None

        Returns:
        None
    """
    # Create a new window
    new_task_window = Toplevel(root)
    new_task_window.title("New 'at' Task")
    new_task_window.geometry("400x150")

    # Add a label and entry for the task name
    Label(new_task_window, text="Task Name:").grid(row=0, column=0)
    task_name_entry = Entry(new_task_window)
    task_name_entry.grid(row=0, column=1)

    # Add a label and entry for the time
    Label(new_task_window, text="Time (HH:MM):").grid(row=1, column=0)
    time_entry = Entry(new_task_window)
    time_entry.grid(row=1, column=1)

    # Add a label and entry for the program path
    Label(new_task_window, text="Program Path:").grid(row=2, column=0)
    program_path_entry = Entry(new_task_window)
    program_path_entry.grid(row=2, column=1)

    # Function to handle creating an 'at' job
    def create_at_job():
        task_name = task_name_entry.get()
        time = time_entry.get()
        program_path = program_path_entry.get()
        # Here you would call the function to create the 'at' job with the given details
        try:
            at_function(task_name, time, program_path)
            messagebox.showinfo("Scheduled", f"Task '{task_name}' scheduled at {time} to run {program_path}")
        except Exception as e:
            messagebox.showerror("Task Execution", f"Error creating at task:\n{str(e)}")

    # Add buttons for creating 'at' and 'crontab' jobs
    Button(new_task_window, text="Create 'at' Job", command=create_at_job).grid(row=3, column=0)

    # Run the window's main event loop
    new_task_window.mainloop()


def open_new_crontab_task_window():
    """
        Opens a window for creating a new 'crontab' task.

        Offers an interface for scheduling a new 'cron' job with detailed time settings and script path.
        It validates the input fields and handles the job creation process.

        Parameters:
        None

        Returns:
        None
    """
    # Create a new window
    new_cron_task_window = Toplevel(root)
    new_cron_task_window.title("New 'crontab' Task")
    new_cron_task_window.geometry("500x300")

    # Add label and entry for each crontab time field
    Label(new_cron_task_window, text="Name:").grid(row=0, column=0)
    name_entry = Entry(new_cron_task_window)
    name_entry.grid(row=0, column=1)

    # Add label and entry for each crontab time field
    Label(new_cron_task_window, text="Minute:").grid(row=1, column=0)
    minute_entry = Entry(new_cron_task_window)
    minute_entry.grid(row=1, column=1)

    Label(new_cron_task_window, text="Hour:").grid(row=2, column=0)
    hour_entry = Entry(new_cron_task_window)
    hour_entry.grid(row=2, column=1)

    Label(new_cron_task_window, text="Day (Month):").grid(row=3, column=0)
    day_month_entry = Entry(new_cron_task_window)
    day_month_entry.grid(row=3, column=1)

    Label(new_cron_task_window, text="Month:").grid(row=4, column=0)
    month_entry = Entry(new_cron_task_window)
    month_entry.grid(row=4, column=1)

    Label(new_cron_task_window, text="Day (Week):").grid(row=5, column=0)
    day_week_entry = Entry(new_cron_task_window)
    day_week_entry.grid(row=5, column=1)

    Label(new_cron_task_window, text="Script Path:").grid(row=6, column=0)
    script_path_entry = Entry(new_cron_task_window)
    script_path_entry.grid(row=6, column=1)

    # Function to handle creating a 'crontab' job
    def create_crontab_job():
        name = name_entry.get()
        minute = minute_entry.get()
        hour = hour_entry.get()
        day_month = day_month_entry.get()
        month = month_entry.get()
        day_week = day_week_entry.get()
        script_path = script_path_entry.get()

        # Validate fields
        if not all([name, minute, hour, day_month, month, day_week, script_path]):
            messagebox.showerror("Error", "All fields must be filled.")
            return

        # Here you would call the function to create the 'crontab' job with the given details
        crontab_function(name, minute, hour, day_month, month, day_week, script_path)
        messagebox.showinfo("Scheduled",
                            f"Crontab task scheduled to run script at {minute} {hour} {day_month} {month} {day_week}.")

    # Add button to create 'crontab' job
    Button(new_cron_task_window, text="Create 'crontab' Job", command=create_crontab_job).grid(row=7, column=0,
                                                                                               columnspan=2)

    # Run the window's main event loop
    new_cron_task_window.mainloop()


script_tasks.py:
from tkinter import messagebox

import markdown


def analyze_csv_data():
    """
        Analyzes data from a CSV file.

        This function is intended to perform analysis on CSV data. Currently, it acts as a placeholder,
        displaying a message about the ongoing CSV analysis process.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for CSV analysis logic
    messagebox.showinfo("CSV Analysis", "Performing CSV analysis.")


def render_markdown_to_html(markdown_text):
    """
        Converts Markdown text to HTML.

        This function takes Markdown formatted text and converts it to HTML using the markdown library.
        It also informs the user about the rendering process.

        Parameters:
        markdown_text (str): The Markdown text to be converted.

        Returns:
        str: The resulting HTML after conversion.
    """
    messagebox.showinfo("Markdown Rendering", "Rendering Markdown to HTML.")
    return markdown.markdown(markdown_text)


def generate_html_from_markdown():
    """
        Generates HTML content from Markdown.

        This is a placeholder function for the logic to convert Markdown to HTML. It currently displays
        a message indicating the start of HTML generation from Markdown.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for generating HTML from Markdown logic
    messagebox.showinfo("HTML Generation", "Generating HTML from Markdown.")


def render_markdown_to_latex():
    messagebox.showinfo("Live PDF Generation", "Generating Live AI PDF from Markdown.")


def run_javascript_analysis():
    """
        Analyzes JavaScript code.

        Placeholder function for implementing logic to analyze JavaScript code. Currently, it displays
        a message indicating the commencement of JavaScript analysis.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for JavaScript analysis logic
    messagebox.showinfo("JavaScript Analysis", "Analyzing JavaScript code.")


def run_python_script():
    """
        Executes a Python script.

        This function is a placeholder for the logic required to run Python scripts. It currently shows
        a message indicating the execution of a Python script.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for running Python script logic
    messagebox.showinfo("Run Python Script", "Running Python script.")


def change_interpreter():
    """
        Changes the Python interpreter.

        Placeholder function for implementing the logic to change the Python interpreter being used.
        Currently, it displays a message indicating the process of changing the interpreter.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for changing Python interpreter logic
    messagebox.showinfo("Change Interpreter", "Changing Python interpreter.")


def analyze_generic_text_data():
    """
        Analyzes generic text data.

        This function is intended as a placeholder for logic to analyze text data. It currently shows
        a message about the ongoing process of analyzing text data.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for generic text data analysis logic
    messagebox.showinfo("Text Data Analysis", "Analyzing generic text data.")


def generate_latex_pdf():
    """
        Generates a PDF from LaTeX source.

        Placeholder for the logic to generate a PDF document from LaTeX source code. Currently, it
        informs the user about the commencement of the LaTeX PDF generation process.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for generating LaTeX PDF logic
    messagebox.showinfo("LaTeX PDF Generation", "Generating LaTeX PDF.")


def render_latex_to_pdf():
    """
        Renders LaTeX source to a PDF document.

        This function is a placeholder for the logic to convert LaTeX source code into a PDF document.
        It currently displays a message indicating the rendering process of LaTeX to PDF.

        Parameters:
        None

        Returns:
        None
    """
    # Placeholder for rendering LaTeX to PDF logic
    messagebox.showinfo("LaTeX Rendering", "Rendering LaTeX to PDF.")

tool_functions.py:
import json
import multiprocessing
import os
import subprocess
import threading
from tkinter import colorchooser, END, Toplevel, Label, Entry, Button, scrolledtext, IntVar, Menu, StringVar, \
    messagebox, OptionMenu
import webview  # pywebview

import markdown
from tkhtmlview import HTMLLabel

from src.views.edit_operations import cut, copy, paste, duplicate
from src.views.tk_utils import text, script_text, root, style
from src.controllers.utility_functions import make_tag


def load_themes_from_json(file_path):
    try:
        with open(file_path, 'r') as file:
            data = json.load(file)
            return data.get('themes', [])
    except FileNotFoundError:
        messagebox.showerror("Error", "Themes file not found.")
        return []
    except json.JSONDecodeError:
        messagebox.showerror("Error", "Error decoding themes file.")
        return []


def open_change_theme_window():
    themes = load_themes_from_json("data/themes.json")

    theme_window = Toplevel(root)
    theme_window.title("Change Theme")
    theme_window.geometry("300x250")

    Label(theme_window, text="Select Theme:").pack(pady=10)

    # Dropdown for theme selection
    selected_theme = StringVar()
    selected_theme.set(themes[0])  # default value
    theme_dropdown = OptionMenu(theme_window, selected_theme, *themes)
    theme_dropdown.pack()

    def apply_theme():
        chosen_theme = selected_theme.get()
        style.theme_use(chosen_theme)

    Button(theme_window, text="Apply", command=apply_theme).pack(pady=20)

def change_color():
    """
        Changes the text color in the application's text widget.

        This function opens a color chooser dialog, allowing the user to select a new color for the text.
        It then applies this color to the text within the text widget.

        Parameters:
        None

        Returns:
        None
    """
    color = colorchooser.askcolor(initialcolor='#ff0000')
    color_name = color[1]
    global fontColor
    fontColor = color_name
    current_tags = text.tag_names()
    if "font_color_change" in current_tags:
        # first char is bold, so unbold the range
        text.tag_delete("font_color_change", 1.0, END)
    else:
        # first char is normal, so bold the whole selection
        text.tag_add("font_color_change", 1.0, END)
    make_tag()


def colorize_text():
    """
        Applies color to the text in the script text widget.

        This function retrieves the current content of the script text widget, deletes it, and reinserts it,
        applying the currently selected color.

        Parameters:
        None

        Returns:
        None
    """
    script_content = script_text.get("1.0", "end")
    script_text.delete("1.0", "end")
    script_text.insert("1.0", script_content)


def check(value):
    """
        Highlights all occurrences of a specified value in the script text widget.

        This function searches for the given value in the script text widget and applies a 'found' tag with a
        yellow background to each occurrence.

        Parameters:
        value (str): The string to be searched for in the text widget.

        Returns:
        None
    """
    script_text.tag_remove('found', '1.0', END)

    if value:
        script_text.tag_config('found', background='yellow')
        idx = '1.0'
        while idx:
            idx = script_text.search(value, idx, nocase=1, stopindex=END)
            if idx:
                lastidx = f"{idx}+{len(value)}c"
                script_text.tag_add('found', idx, lastidx)
                idx = lastidx


def search_and_replace(search_text, replace_text):
    """
        Replaces all occurrences of a specified search text with a replacement text in the script text widget.

        This function finds each occurrence of the search text and replaces it with the provided replacement text.

        Parameters:
        search_text (str): The text to be replaced.
        replace_text (str): The text to replace the search text.

        Returns:
        None
    """
    if search_text:
        start_index = '1.0'
        while True:
            start_index = script_text.search(search_text, start_index, nocase=1, stopindex=END)
            if not start_index:
                break
            end_index = f"{start_index}+{len(search_text)}c"
            script_text.delete(start_index, end_index)
            script_text.insert(start_index, replace_text)
            start_index = end_index


def find_text(event=None):
    """
        Opens a dialog for finding text within the script text widget.

        This function creates a new window with an entry field where the user can input a text string
        to find in the script text widget.

        Parameters:
        event (Event, optional): The event that triggered this function.

        Returns:
        None
    """
    search_toplevel = Toplevel(root)
    search_toplevel.title('Find Text')
    search_toplevel.transient(root)
    search_toplevel.resizable(False, False)
    Label(search_toplevel, text="Find All:").grid(row=0, column=0, sticky='e')
    search_entry_widget = Entry(search_toplevel, width=25)
    search_entry_widget.grid(row=0, column=1, padx=2, pady=2, sticky='we')
    search_entry_widget.focus_set()
    Button(search_toplevel,
           text="Ok",
           underline=0,
           command=lambda: check(search_entry_widget.get())).grid(row=0,
                                                                  column=2,
                                                                  sticky='e' + 'w',
                                                                  padx=2,
                                                                  pady=5
                                                                  )
    Button(search_toplevel,
           text="Cancel",
           underline=0,
           command=lambda: find_text_cancel_button(search_toplevel)).grid(row=0,
                                                                          column=4,
                                                                          sticky='e' + 'w',
                                                                          padx=2,
                                                                          pady=2
                                                                          )


# remove search tags and destroys the search box
def find_text_cancel_button(search_toplevel):
    """
        Removes search highlights and closes the search dialog.

        This function is called to close the search dialog and remove any search highlights
        from the text widget.

        Parameters:
        search_toplevel (Toplevel): The top-level widget of the search dialog.

        Returns:
        None
    """
    text.tag_remove('found', '1.0', END)
    search_toplevel.destroy()
    return "break"


def open_search_replace_dialog():
    """
        Opens a dialog for searching and replacing text within the script text widget.

        This function creates a new window with fields for inputting the search and replace texts
        and a button to execute the replacement.

        Parameters:
        None

        Returns:
        None
    """
    search_replace_toplevel = Toplevel(root)
    search_replace_toplevel.title('Search and Replace')
    search_replace_toplevel.transient(root)
    search_replace_toplevel.resizable(False, False)

    # Campo de b√∫squeda
    Label(search_replace_toplevel, text="Find:").grid(row=0, column=0, sticky='e')
    search_entry_widget = Entry(search_replace_toplevel, width=25)
    search_entry_widget.grid(row=0, column=1, padx=2, pady=2, sticky='we')

    # Campo de reemplazo
    Label(search_replace_toplevel, text="Replace:").grid(row=1, column=0, sticky='e')
    replace_entry_widget = Entry(search_replace_toplevel, width=25)
    replace_entry_widget.grid(row=1, column=1, padx=2, pady=2, sticky='we')

    # Botones
    Button(
        search_replace_toplevel,
        text="Replace All",
        command=lambda: search_and_replace(search_entry_widget.get(),
                                           replace_entry_widget.get())).grid(row=2,
                                                                             column=1,
                                                                             sticky='e' + 'w',
                                                                             padx=2,
                                                                             pady=5
                                                                             )


def open_ipython_terminal_window():
    print("OPEN IPYTHON TERMINAL")


def open_terminal_window():
    """
        Opens a new window functioning as a terminal within the application.

        This function creates a top-level window that simulates a terminal, allowing users to
        enter and execute commands with output displayed in the window.

        Parameters:
        None

        Returns:
        None
    """
    terminal_window = Toplevel()
    terminal_window.title("Python Terminal")
    terminal_window.geometry("600x400")

    # Create a ScrolledText widget to display terminal output
    output_text = scrolledtext.ScrolledText(terminal_window, height=20, width=80)
    output_text.pack(fill='both', expand=True)

    # Initialize a list to store command history
    command_history = []
    # Initialize a pointer to the current position in the command history
    history_pointer = [0]

    # Function to execute the command from the entry widget
    def execute_command(event=None):
        # Get the command from entry widget
        command = entry.get()
        if command.strip():
            # Add command to history and reset history pointer
            command_history.append(command)
            history_pointer[0] = len(command_history)

            try:
                # Run the command and get the output
                output = subprocess.check_output(command,
                                                 stderr=subprocess.STDOUT,
                                                 shell=True,
                                                 text=True,
                                                 cwd=os.getcwd())
                output_text.insert(END, f"{command}\n{output}\n")
            except subprocess.CalledProcessError as e:
                # If there's an error, print it to the output widget
                output_text.tag_configure("error", foreground="red")
                output_text.insert(END, f"Error: {e.output}", "error")
            # Clear the entry widget
            entry.delete(0, END)
            output_text.see(END)  # Auto-scroll to the bottom

    # Function to navigate the command history
    def navigate_history(event):
        if command_history:
            # UP arrow key pressed
            if event.keysym == 'Up':
                history_pointer[0] = max(0, history_pointer[0] - 1)
            # DOWN arrow key pressed
            elif event.keysym == 'Down':
                history_pointer[0] = min(len(command_history), history_pointer[0] + 1)
            # Get the command from history
            command = command_history[history_pointer[0]] if history_pointer[0] < len(command_history) else ''
            # Set the command to the entry widget
            entry.delete(0, END)
            entry.insert(0, command)

    # Create an Entry widget for typing commands
    entry = Entry(terminal_window, width=80)
    entry.pack(side='bottom', fill='x')
    entry.focus()
    entry.bind("<Return>", execute_command)
    # Bind the UP and DOWN arrow keys to navigate the command history
    entry.bind("<Up>", navigate_history)
    entry.bind("<Down>", navigate_history)


def add_current_main_opened_script(include_main_script):
    global include_main_script_in_command
    include_main_script_in_command = include_main_script


def add_current_selected_text(include_selected_text):
    global include_selected_text_in_command
    include_selected_text_in_command = include_selected_text


def open_ai_server_settings_window():
    settings_window = Toplevel(root)
    settings_window.title("AI Server Settings")
    settings_window.geometry("400x300")

    Label(settings_window, text="Server URL:").grid(row=0, column=0)
    server_url_entry = Entry(settings_window, width=25)
    server_url_entry.insert(0, "http://localhost:1234/v1")  # Default URL
    server_url_entry.grid(row=0, column=1)

    Label(settings_window, text="API Key:").grid(row=1, column=0)
    api_key_entry = Entry(settings_window, width=25)
    api_key_entry.insert(0, "not-needed")  # Default API Key
    api_key_entry.grid(row=1, column=1)

    # Placeholder for listing and managing saved server connections
    # This could be implemented using Listbox or similar widget

    Button(settings_window, text="Save", command=lambda: save_ai_server_settings(server_url_entry.get(), api_key_entry.get())).grid(row=3, column=0, columnspan=2)

    settings_window.mainloop()


def save_ai_server_settings(server_url, api_key):
    settings = {'server_url': server_url, 'api_key': api_key}
    # TODO: Here you would save these settings to a file or database
    # For now, we'll just print them
    print("Saved AI Server Settings:", settings)
    messagebox.showinfo("AI Server Settings", "Settings saved successfully!")


def open_ai_assistant_window():
    """
        Opens a window for interacting with an AI assistant.

        This function creates a new window where users can input commands or queries, and the AI assistant
        processes and displays the results. It also provides options for rendering Markdown to HTML.

        Parameters:
        None

        Returns:
        None
    """
    global original_md_content, markdown_render_enabled, rendered_html_content
    original_md_content = ""
    rendered_html_content = ""
    markdown_render_enabled = False

    ai_assistant_window = Toplevel()
    ai_assistant_window.title("AI Assistant")
    ai_assistant_window.geometry("600x400")

    # Create a Menu Bar
    menu_bar = Menu(ai_assistant_window)
    ai_assistant_window.config(menu=menu_bar)

    # Create a 'Settings' Menu
    settings_menu = Menu(menu_bar, tearoff=0)
    menu_bar.add_cascade(label="Settings", menu=settings_menu)
    menu_bar.add_command(label="AI Server Settings", command=open_ai_server_settings_window)
    # menu_bar.add_command(label="Manage Servers", command=manage_servers)
    render_markdown_var = IntVar()
    settings_menu.add_checkbutton(
        label="Toggle Markdown-to-HTML Rendering",
        onvalue=1,
        offvalue=0,
        variable=render_markdown_var,
        command=lambda: toggle_render_markdown(render_markdown_var.get())
    )

    add_current_main_opened_script_var = IntVar()
    settings_menu.add_checkbutton(
        label="Include Main Script in AI Context",
        onvalue=1,
        offvalue=0,
        variable=add_current_main_opened_script_var,
        command=lambda: add_current_main_opened_script(add_current_main_opened_script_var.get())
    )

    add_current_selected_text_var = IntVar()
    settings_menu.add_checkbutton(
        label="Include Selected Text from Script",
        onvalue=1,
        offvalue=0,
        variable=add_current_selected_text_var,
        command=lambda: add_current_selected_text(add_current_selected_text_var.get())
    )

    # Create the output text widget
    output_text = scrolledtext.ScrolledText(ai_assistant_window, height=20, width=80)
    output_text.pack(fill='both', expand=True)

    html_display = HTMLLabel(ai_assistant_window, html="", )

    html_display.pack(fill='both', expand=False)
    html_display.pack_forget()  # Initially hide the HTML display

    entry = Entry(ai_assistant_window, width=30)
    entry.pack(side='bottom', fill='x')

    status_label_var = StringVar()
    status_label = Label(ai_assistant_window, textvariable=status_label_var)
    status_label.pack(side='bottom')  # This will keep the status label at the bottom
    status_label_var.set("READY")  # Initialize the status label as "READY"

    output_text.insert(END, "> ")

    entry.focus()

    def on_md_content_change(event=None):
        global original_md_content
        original_md_content = script_text.get("1.0", END)
        print("on_md_content_change: original_md_content updated")  # Debug print
        if markdown_render_enabled:
            print("on_md_content_change: markdown_render_enabled is True, updating HTML content")  # Debug print
            update_html_content()
        else:
            print("on_md_content_change: markdown_render_enabled is False")  # Debug print

    def update_html_content():
        global rendered_html_content
        rendered_html_content = markdown.markdown(original_md_content)
        html_display.set_html(rendered_html_content)

        if hasattr(html_display, 'yview_moveto'):
            html_display.yview_moveto(1.0)

    def toggle_render_markdown(is_checked):
        global markdown_render_enabled
        markdown_render_enabled = bool(is_checked)

        if markdown_render_enabled:
            update_html_content()
            output_text.pack_forget()
            html_display.pack(fill='both', expand=True)
        else:
            output_text.delete("1.0", "end")
            output_text.insert("1.0", original_md_content)
            html_display.pack_forget()
            output_text.pack(fill='both', expand=True)

    def navigate_history(event):
        if command_history:
            # UP arrow key pressed
            if event.keysym == 'Up':
                history_pointer[0] = max(0, history_pointer[0] - 1)
            # DOWN arrow key pressed
            elif event.keysym == 'Down':
                history_pointer[0] = min(len(command_history), history_pointer[0] + 1)
            # Get the command from history
            command = command_history[history_pointer[0]] if history_pointer[0] < len(command_history) else ''
            # Set the command to the entry widget
            entry.delete(0, END)
            entry.insert(0, command)

    def stream_output(process):
        try:
            output_buffer = ""  # Initialize an empty buffer
            buffer_size = 2  # Set the size of the buffer to hold the last two characters

            while True:
                char = process.stdout.read(1)  # Read one character at a time
                if char:
                    global original_md_content
                    original_md_content += char

                    if markdown_render_enabled:
                        # Update HTML content
                        update_html_content()
                    else:
                        # Update Markdown content
                        output_text.insert(END, char)
                        output_text.see(END)

                    # Update buffer
                    output_buffer += char
                    output_buffer = output_buffer[-buffer_size:]

                    if output_buffer == '> ':
                        break
                elif process.poll() is not None:
                    break
        except Exception as e:
            output_text.insert(END, f"Error: {e}\n")
        finally:
            on_processing_complete()

    def on_processing_complete():
        print("Debug: Processing complete, re-enabling entry widget.")  # Debug print
        entry.config(state='normal')  # Re-enable the entry widget
        status_label_var.set("READY")  # Update label to show AI is processing

    def execute_ai_assistant_command(add_current_main_opened_script_var, add_current_selected_text_var):
        global process, original_md_content

        ai_command = entry.get()
        if ai_command.strip():
            script_content = ""
            if add_current_selected_text_var.get():
                # Use only selected text from the main script window
                try:
                    script_content = "```\n" + script_text.get(script_text.tag_ranges("sel")[0],
                                                               script_text.tag_ranges("sel")[1]) + "```\n\n"
                except:
                    messagebox.showerror("Error", "No text selected in main script window.")
                    return
            elif add_current_main_opened_script_var.get():
                # Use full content of the main script window
                script_content = "```\n" + script_text.get("1.0", END) + "```\n\n"

            combined_command = f"{script_content}{ai_command}"

            # Insert the user command with a newline and a visual separator
            original_md_content += f"\n{combined_command}\n"
            original_md_content += "-" * 80 + "\n"  # A line of dashes as a separator
            output_text.insert("end", f"You: {combined_command}\n")
            output_text.insert("end", "-" * 80 + "\n")
            entry.delete(0, END)
            entry.config(state='disabled')  # Disable entry while processing
            status_label_var.set("AI is thinking...")  # Update label to show AI is processing

            ai_script_path = r"C:\Users\AxelFC\Documents\git\UE5-python\Content\Python\src\text\ai_assistant.py"
            command = ['python', ai_script_path, combined_command]

            # Terminate existing subprocess if it exists
            if 'process' in globals() and process.poll() is None:
                process.terminate()

            try:
                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True,
                                           encoding='utf-8', bufsize=1)
                threading.Thread(target=stream_output, args=(process,)).start()
            except Exception as e:
                output_text.insert(END, f"Error: {e}\n")
                on_processing_complete()
            finally:
                update_html_content()
        else:
            entry.config(state='normal')  # Re-enable the entry widget if no command is entered

    def show_context_menu(event):
        # Create the context menu
        context_menu = Menu(root, tearoff=0)
        context_menu.add_command(label="Cut Text", command=cut)
        context_menu.add_command(label="Copy Text", command=copy)
        context_menu.add_command(label="Paste Text", command=paste)
        context_menu.add_command(label="Duplicate Text", command=duplicate)

        # Post the context menu at the cursor location
        context_menu.post(event.x_root, event.y_root)

        # Give focus to the context menu
        context_menu.focus_set()

        def destroy_menu():
            context_menu.unpost()

        # Bind the <Leave> event to destroy the context menu when the mouse cursor leaves it
        context_menu.bind("<Leave>", lambda e: destroy_menu())

        # Bind the <FocusOut> event to destroy the context menu when it loses focus
        context_menu.bind("<FocusOut>", lambda e: destroy_menu())

    output_text.bind("<Button-3>", show_context_menu)

    output_text.bind("<<TextModified>>", on_md_content_change)
    output_text.see(END)

    entry.bind("<Return>", lambda event: execute_ai_assistant_command(
        add_current_main_opened_script_var,
        add_current_selected_text_var)
               )

    entry.bind("<Up>", navigate_history)
    entry.bind("<Down>", navigate_history)

    # Initialize a list to store command history
    command_history = []
    # Initialize a pointer to the current position in the command history
    history_pointer = [0]

    print("open_ai_assistant_window: Window opened")  # Debug print
    ai_assistant_window.mainloop()
    print("open_ai_assistant_window: Mainloop ended")  # Debug print


# Define _create_webview_process at the top level
def _create_webview_process(title, url):
    webview.create_window(title, url, width=800, height=600, text_select=True, zoomable=True)
    webview.start(private_mode=True)


def open_webview(title, url):
    webview_process = multiprocessing.Process(target=_create_webview_process, args=(title, url,))
    webview_process.start()


def open_url_in_webview(url):
    webview.create_window("My Web Browser", url, width=800, height=600, text_select=True, zoomable=True,
                          easy_drag=True, confirm_close=True, background_color="#1f1f1f")
    webview.start(private_mode=True)


def on_go_button_clicked(entry, window):
    url = entry.get()
    if not url.startswith("http://") and not url.startswith("https://"):
        url = "https://" + url  # Prepend 'https://' if not present
    on_close(window)
    webview_process = multiprocessing.Process(target=open_url_in_webview, args=(url,))
    webview_process.start()


def create_url_input_window():
    # Change this to Toplevel
    window = Toplevel(root)  # Use the existing root from Tkinter
    window.title("Enter URL")

    entry = Entry(window, width=50)
    entry.insert(0, "https://duckduckgo.com")
    entry.pack(padx=10, pady=10)
    entry.focus()

    go_button = Button(window, text="Go", command=lambda: on_go_button_clicked(entry, window))
    go_button.pack(pady=5)

    window.bind('<Return>', lambda event: on_go_button_clicked(entry, window))


def on_enter(event, entry, window):
    """Event handler to trigger navigation when Enter key is pressed."""
    on_go_button_clicked(entry, window)


def on_close(window):
    # Terminate the subprocesses here if any
    # Clean up resources
    window.destroy()

utility_functions.py:
import tkinter
from tkinter import END, messagebox, colorchooser

from src.views.tk_utils import text, all_fonts, all_size, fontColor


def bold(event=None):
    """
        Toggles bold formatting on the entire text in a text widget.

        This function applies or removes bold formatting to all text in the text widget. If any text is already
        bold, it removes the bold formatting. Otherwise, it makes the entire text bold.

        Parameters:
        event (Event, optional): The event object (not used in the function, but necessary for binding).

        Returns:
        None
    """
    current_tags = text.tag_names()
    if "bold" in current_tags:
        # first char is bold, so unbold the range
        text.tag_delete("bold", 1.0, END)
    else:
        # first char is normal, so bold the whole selection
        text.tag_add("bold", 1.0, END)
    make_tag()


def italic(event=None):
    """
        Toggles italic formatting on the entire text in a text widget.

        This function applies or removes italic formatting to all text in the text widget. If any text is already
        italic, it switches to normal. Otherwise, it makes the entire text italic.

        Parameters:
        event (Event, optional): The event object (not used in the function, but necessary for binding).

        Returns:
        None
    """
    current_tags = text.tag_names()
    if "italic" in current_tags:
        text.tag_add("roman", 1.0, END)
        text.tag_delete("italic", 1.0, END)
    else:
        text.tag_add("italic", 1.0, END)
    make_tag()


def underline(event=None):
    """
        Toggles underline formatting on the entire text in a text widget.

        This function applies or removes underline formatting to all text in the text widget. If any text is
        already underlined, it removes the underline. Otherwise, it underlines the entire text.

        Parameters:
        event (Event, optional): The event object (not used in the function, but necessary for binding).

        Returns:
        None
    """
    current_tags = text.tag_names()
    if "underline" in current_tags:
        text.tag_delete("underline", 1.0, END)
    else:
        text.tag_add("underline", 1.0, END)
    make_tag()


def strike():
    """
        Toggles strikethrough formatting on the entire text in a text widget.

        This function applies or removes strikethrough formatting to all text in the text widget. If any text
        is already stricken through, it removes the strikethrough. Otherwise, it applies strikethrough to the
        entire text.

        Parameters:
        None

        Returns:
        None
    """
    current_tags = text.tag_names()
    if "overstrike" in current_tags:
        text.tag_delete("overstrike", "1.0", END)

    else:
        text.tag_add("overstrike", 1.0, END)

    make_tag()


def highlight():
    """
        Applies background color to the entire text in a text widget.

        This function opens a color chooser dialog and applies the selected color as the background color to all
        text in the text widget.

        Parameters:
        None

        Returns:
        None
    """
    color = colorchooser.askcolor(initialcolor='white')
    color_rgb = color[1]
    global fontBackground
    fontBackground = color_rgb
    current_tags = text.tag_names()
    if "background_color_change" in current_tags:
        text.tag_delete("background_color_change", "1.0", END)
    else:
        text.tag_add("background_color_change", "1.0", END)
    make_tag()


def align_center(event=None):
    """
        Aligns the entire text in a text widget to the center.

        This function centers all the text in the text widget. It removes any other alignment tags before
        applying the center alignment.

        Parameters:
        event (Event, optional): The event object (not used in the function, but necessary for binding).

        Returns:
        None
    """
    remove_align_tags()
    text.tag_configure("center", justify='center')
    text.tag_add("center", 1.0, "end")


def align_justify():
    remove_align_tags()


def align_left(event=None):
    remove_align_tags()
    text.tag_configure("left", justify='left')
    text.tag_add("left", 1.0, "end")


def align_right(event=None):
    remove_align_tags()
    text.tag_configure("right", justify='right')
    text.tag_add("right", 1.0, "end")


def change_font(event):
    """
        Changes the font family of the entire text in a text widget.

        This function changes the font family based on the selection from a dropdown or similar widget. The
        global variable 'current_font_family' is updated with the new font family.

        Parameters:
        event (Event): The event object (used for binding to a widget event).

        Returns:
        None
    """
    f = all_fonts.get()
    global current_font_family
    current_font_family = f
    make_tag()


def change_size(event):
    """
        Changes the font size of the entire text in a text widget.

        This function changes the font size based on the selection from a dropdown or similar widget. The global
        variable 'current_font_size' is updated with the new font size.

        Parameters:
        event (Event): The event object (used for binding to a widget event).

        Returns:
        None
    """
    sz = int(all_size.get())
    global current_font_size
    current_font_size = sz
    make_tag()


def make_tag():
    """
        Applies combined text formatting based on the current tags in a text widget.

        This function checks for the presence of formatting tags (bold, italic, underline, overstrike) and applies
        them together to the entire text in the text widget. It also applies the current font family and size.

        Parameters:
        None

        Returns:
        None
    """
    current_tags = text.tag_names()
    if "bold" in current_tags:
        weight = "bold"
    else:
        weight = "normal"

    if "italic" in current_tags:
        slant = "italic"
    else:
        slant = "roman"

    if "underline" in current_tags:
        underline = 1
    else:
        underline = 0

    if "overstrike" in current_tags:
        overstrike = 1
    else:
        overstrike = 0

    big_font = tkinter.font.Font(text, text.cget("font"))
    big_font.configure(slant=slant, weight=weight, underline=underline, overstrike=overstrike,
                       family=current_font_family, size=current_font_size)
    text.tag_config("BigTag", font=big_font, foreground=fontColor, background=fontBackground)
    if "BigTag" in current_tags:
        text.tag_remove("BigTag", 1.0, END)
    text.tag_add("BigTag", 1.0, END)


def remove_align_tags():
    """
        Removes all alignment tags from a text widget.

        This function removes any existing alignment tags (center, left, right) from the text widget, effectively
        resetting the alignment.

        Parameters:
        None

        Returns:
        None
    """
    all_tags = text.tag_names(index=None)
    if "center" in all_tags:
        text.tag_remove("center", "1.0", END)
    if "left" in all_tags:
        text.tag_remove("left", "1.0", END)
    if "right" in all_tags:
        text.tag_remove("right", "1.0", END)


def validate_time(hour, minute):
    """
        Validates the given hour and minute to ensure they form a valid time.

        This function checks if the provided hour and minute values form a valid time (HH:MM format). It displays
        an error message if the time is invalid.

        Parameters:
        hour (str or int): The hour part of the time.
        minute (str or int): The minute part of the time.

        Returns:
        bool: True if the time is valid, False otherwise.
    """
    try:
        hour = int(hour)
        minute = int(minute)
        if not (0 <= hour < 24) or not (0 <= minute < 60):
            raise ValueError
        return True
    except ValueError:
        messagebox.showerror("Invalid Time", "Please enter a valid time in HH:MM format.")
        return False



```

